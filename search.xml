<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>dice-loss的思考</title>
      <link href="/2018/11/06/dice-loss/"/>
      <url>/2018/11/06/dice-loss/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>为了验证<code>dice</code>作为<code>loss function</code>，是否会被分割物体面积的大小所影响，设计本实验。</p><a id="more"></a><h1 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h1><p>控制住GrundTruth不便，预测结果从小到大线性变化，另外给预测的右下脚加一个假阳性区域。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><!-- ![](./images/1.png) --><img src="/2018/11/06/dice-loss/1.png" class=""><h1 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h1><p>让ground truth 和预测的结果同时非线性的变大，保持预测结果和ground truth的误差为同一个值。</p><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><!-- ![](./images/Figure_1.png) --><img src="/2018/11/06/dice-loss/Figure_1.png" class=""><h1 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h1><p>让ground truth非线性变大，但是预测的结果总是ground truth的0.5倍，且重合。</p><h2 id="结果1"><a href="#结果1" class="headerlink" title="结果1"></a>结果1</h2><p><strong>此时smooth为1e-5</strong></p><!-- ![](./images/1e-5.png) --><img src="/2018/11/06/dice-loss/1e-5.png" class=""><h2 id="结果2"><a href="#结果2" class="headerlink" title="结果2"></a>结果2</h2><p><strong>此时smooth为1e-20</strong></p><!-- ![](./images/1e-20.png) --><img src="/2018/11/06/dice-loss/1e-20.png" class=""><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ol><li><p>由实验1结果可以看出：<strong>随着预测面积的线性变化，dice是非线性变化的，而jaccard是线性变化的</strong></p></li><li><p>由实验1结果，实验2结果，实验3结果可以看出：<strong>相同情况下dice的数值会比jaccard的数值更高一些</strong></p></li><li><p>从实验3中的结果2看出：<strong>无论是dice还是jaccard，他们都不会受到图像面积大小的影响，而只和面积重合率有关</strong></p></li><li><p>从实验3中的两个结果可以看出：<strong>smooth项会对结果产生一定的影响，因此需要根据所需的实验精度设置smooth项，否则会受到影响</strong></p></li></ol><p>综上，<code>dice</code>作为<code>loss function</code>不会受到被分割物体面积的影响。</p>]]></content>
      
      
      <categories>
          
          <category> deep learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python:异常处理</title>
      <link href="/2018/11/03/python-exception/"/>
      <url>/2018/11/03/python-exception/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文主要介绍python的异常处理机制，包括：</p><ol><li>如何使用异常处理</li><li>异常的传递</li><li>抛出异常</li></ol><p>由于比较简单，因此这里介绍的不是很详细。</p><p>有一些代码来源于网络。</p><a id="more"></a><h1 id="如何使用异常处理"><a href="#如何使用异常处理" class="headerlink" title="如何使用异常处理"></a>如何使用异常处理</h1><p>所有的面向对象语言对异常的处理方式大同小异，在python中的处理异常的结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能出错的程序</span></span><br><span class="line"><span class="keyword">except</span> (Exception1, Exception2):     <span class="comment"># 注意，python3中如果同时处理多个异常,需要将多个异常放在元组中。</span></span><br><span class="line">    <span class="comment"># 捕获到异常后对应的处理方法                         </span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 捕获到异常后对应的处理方法</span></span><br><span class="line">    print(e)</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    <span class="comment"># 如果没有捕获到异常对应处理方法</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 触发异常或者不触发异常都需要处理的部分</span></span><br></pre></td></tr></table></figure><p>接下来我们对上述结构逐一介绍。</p><h2 id="try-…-except"><a href="#try-…-except" class="headerlink" title="try … except"></a>try … except</h2><p><code>try</code>里面放可能出现问题的代码<br><code>except</code>里面放捕获到错误之后的处理的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'捕获到的错误信息：'</span>,e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line">捕获到的错误信息： name <span class="string">'num'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h2 id="except-捕获多个异常"><a href="#except-捕获多个异常" class="headerlink" title="except 捕获多个异常"></a>except 捕获多个异常</h2><p>直接在except将多个异常的名字放在元组里即可:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    open(<span class="string">'hahaha'</span>)</span><br><span class="line"><span class="keyword">except</span> (NameError, IOError):</span><br><span class="line">    print(<span class="string">'catch exception'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line">catch exception</span><br></pre></td></tr></table></figure><h2 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h2><p><code>Exception</code>类是所有异常类的父类，可以直接用<code>Exception</code>接收所有异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"> name <span class="string">'num'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><h2 id="else"><a href="#else" class="headerlink" title="else"></a>else</h2><p>当没有异常使，可以用<code>else</code>处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'not catch IOError!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output </span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="keyword">not</span> catch IOError!</span><br></pre></td></tr></table></figure><h2 id="try-…-finally"><a href="#try-…-finally" class="headerlink" title="try … finally"></a>try … finally</h2><p>无论检测到还是检测不到异常，有些代码都需要执行，此时放在<code>finally</code>里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'test.txt'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            content = f.readline()</span><br><span class="line">            <span class="keyword">if</span> len(content) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            print(content)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment">#如果在读取文件的过程中，产生了异常，那么就会捕获到</span></span><br><span class="line">        <span class="comment">#比如 按下了 ctrl+c</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line">        print(<span class="string">'关闭文件'</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"没有这个文件"</span>)</span><br></pre></td></tr></table></figure><h1 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h1><p>使用<code>try ... except</code>捕获异常还有一个好处，即异常可以跨越多层进行传递。如下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"----test1-1----"</span>)</span><br><span class="line">    print(num)</span><br><span class="line">    print(<span class="string">"----test1-2----"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"----test3-1----"</span>)</span><br><span class="line">        test1()</span><br><span class="line">        print(<span class="string">"----test3-2----"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">        print(<span class="string">"捕获到了异常，信息是:%s"</span>%result)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"----test3-3----"</span>)</span><br><span class="line"></span><br><span class="line">test3()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line">----test3<span class="number">-1</span>----</span><br><span class="line">----test1<span class="number">-1</span>----</span><br><span class="line">捕获到了异常，信息是:<span class="keyword">global</span> name <span class="string">'num'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">----test3<span class="number">-3</span>----</span><br></pre></td></tr></table></figure><p>这样我们就可以不必在每个可能出现错误的地方都写上<code>try</code>，而只需要在合适的层次进行处理即可。</p><h1 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h1><h2 id="抛出已有异常"><a href="#抛出已有异常" class="headerlink" title="抛出已有异常"></a>抛出已有异常</h2><p>可以通过<code>raise</code>来将捕获到的异常再抛出去。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, switch)</span>:</span></span><br><span class="line">        self.switch = switch <span class="comment">#开关</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> a/b</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">            <span class="keyword">if</span> self.switch:</span><br><span class="line">                print(<span class="string">"捕获开启，已经捕获到了异常，信息如下:"</span>)</span><br><span class="line">                print(result)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#重新抛出这个异常，此时就不会被这个异常处理给捕获到，从而触发默认的异常处理</span></span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">a = Test(<span class="literal">True</span>)</span><br><span class="line">a.calc(<span class="number">11</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"----------------------华丽的分割线----------------"</span>)</span><br><span class="line"></span><br><span class="line">a.switch = <span class="literal">False</span></span><br><span class="line">a.calc(<span class="number">11</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Output </span></span><br><span class="line">捕获开启，已经捕获到了异常，信息如下:</span><br><span class="line">integer division <span class="keyword">or</span> modulo by zero</span><br><span class="line">----------------------华丽的分割线----------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">23</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a.calc(<span class="number">11</span>,<span class="number">0</span>)</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> calc</span><br><span class="line">    <span class="keyword">return</span> a/b</span><br><span class="line">ZeroDivisionError: integer division <span class="keyword">or</span> modulo by zero</span><br></pre></td></tr></table></figure><h2 id="抛出自定义异常"><a href="#抛出自定义异常" class="headerlink" title="抛出自定义异常"></a>抛出自定义异常</h2><p>自定义异常需要继承<code>Exception</code>类即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*- </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num, max_)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">        self.max_ = max_</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="number">101</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">raise</span> NumError(num, <span class="number">100</span>)</span><br><span class="line"><span class="keyword">except</span> NumError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'%d is too large, max is %d'</span> %(e.num, e.max_))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="number">101</span> <span class="keyword">is</span> too large, max <span class="keyword">is</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python:单例设计模式</title>
      <link href="/2018/10/20/python-single-instance/"/>
      <url>/2018/10/20/python-single-instance/</url>
      
        <content type="html"><![CDATA[<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>本文主要讲两个问题：</p><ol><li><p>pyhton创建一个对象的过程。</p></li><li><p>单例设计模式的一种实现方式。</p></li></ol><a id="more"></a><blockquote><blockquote><p>插曲: 这两天无意中参加了一次笔试，发现一个问题，当然也是我们一直在讨论的一个问题：1， 我们对于计算机语言的理解，数据结构和算法方面和专业的程序员相比还有很多不足，因此必须花时间把这块短板补上。2， 但是从另一个角度来讲，校招笔试的题目很多也都是有套路的，因此个人认为如果多刷题又可以答得不错，并且只要平时功夫做到，笔试之前做好准备工作体现出应试者的一个良好的态度, 这一关应该不是很难。</p></blockquote></blockquote><h1 id="python-创建一个对象的过程"><a href="#python-创建一个对象的过程" class="headerlink" title="python 创建一个对象的过程"></a>python 创建一个对象的过程</h1><p>当我们实例化一个对象的时候，基本上可以分为如下步骤：</p><ol><li><p>调用<code>__new__(cls)</code>方法来创建一个对象，然后找了一个变量来接受<code>__new__</code>的返回值，这个返回值表示创建出来的对象的引用</p></li><li><p>调用<code>__init__(刚创建出来的对象的引用)</code>方法，初始化成员变量。</p></li><li><p>返回对象的引用</p></li></ol><p>注意，这里<code>__new__</code>方法里面需要传递的参数是<code>cls</code>，指的是</p><blockquote><blockquote><p>我们可以拿<code>python</code>创建一个对象的过程和<code>c++</code>的构造函数做个对比。显然<code>c++</code>的构造函数即负责创建对象，又负责初始化成员变量； 而<code>python</code>是通过两个步骤来完成的：<code>__new__(cls)</code>方法只负责创建对象，<code>__init__</code>方法只负责初始化成员变量。</p></blockquote></blockquote><blockquote><blockquote><p>从上面的总结来看，一个常见的误区就是<strong>错误的把<code>__init__</code>方法等价于构造函数，严格来说他们是不等价的。</strong></p></blockquote></blockquote><h1 id="单例模式的一种实现方式"><a href="#单例模式的一种实现方式" class="headerlink" title="单例模式的一种实现方式"></a>单例模式的一种实现方式</h1><p>有了上述<code>__new__</code>方法的机制，我们可以设计一个单例模式如下：</p><p>这里增加了一个附加的东西，即<strong>设计一个单例的同时只初始化一次成员变量</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span></span><br><span class="line">    __init_flag = <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance == <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span> <span class="comment"># 这里通过设置一个类属性的方式实现了只初始化一次成员变量的目的</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Singleton.__init_flag:</span><br><span class="line">            self.num = num</span><br><span class="line">            Singleton.__init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">s = Singleton(<span class="number">100</span>)</span><br><span class="line">print(s.num)</span><br><span class="line"></span><br><span class="line">s1 = Singleton(<span class="number">200</span>) <span class="comment"># 第二次初始化参数时不会打印200</span></span><br><span class="line">print(s1.num)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医学图像分割:随机游走算法(Random Walk Algorithm)</title>
      <link href="/2018/10/15/medical-image-seg-random-walker/"/>
      <url>/2018/10/15/medical-image-seg-random-walker/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Random Walk 算法是比较早的一种基于图的方法，其原始论文<code>[1]</code>最早发在一个会议上, 后来经过修整发在期刊上<code>[2]</code>.</p><p>其主要思想是将图像构建成一个无向图模型，然后通过求解对应的<a href="https://en.wikipedia.org/wiki/Dirichlet_problem" target="_blank" rel="noopener">dirichlet问题</a><code>[3, 4]</code>得到分割结果。</p><p>本文主要介绍一些random walker<strong>算法的原理</strong>，<strong>推导过程</strong>以及一些<strong>实验结果</strong>。</p><a id="more"></a><h1 id="基于图的分割算法基本概念"><a href="#基于图的分割算法基本概念" class="headerlink" title="基于图的分割算法基本概念"></a>基于图的分割算法基本概念</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>基于图的分割方式被广泛使用在自然图像以及医学图像分割中，如<a href="https://en.wikipedia.org/wiki/Cut_(graph_theory" target="_blank" rel="noopener">graph cut</a>, <code>grab cut</code>, <code>MRF-MAP</code>, <code>CRF</code>, <code>fc-crf</code>等等一些方法，本文主要介绍基于图的其中一种方法，叫<code>random walk</code>算法。</p><p>首先简要介绍一些图的基本概念：</p><p>一个图模型是一组节点和边的集合：$G=(V,E)$,其中$v\in V$叫做图节点(vertices, nodes),$e\in E \subseteq V \times V$叫做图像的边，连接了一个图像的两个节点$v_i v_j$的边我们用$e_{ij}$表示。</p><p>每一条边我们都给它定义一个权重$w_{ij}$,注意，这里的权重需要满足$w_{ij}&gt;0$。</p><p>还有一个概念是一个节点的<code>度（degree）</code>我们定义如下：<br>$$<br>\begin{equation}<br>d_i = \sum{w(e_{ij})}<br>\end{equation}<br>$$<br>这个意思是每个节点的度等于和它相连的边上的权重之和，表示了这个节点的一个属性。</p><p>下面的这个图就是一种将我们常见的2维图像表达成图的一种方式（注意，我这里说的是<code>一种方式</code>，说明还有其他的方式，比如下图定义的是节点之间4连通的方式，我们还可以定义为8连通的方式，甚至定义为全连接的方式）。其中圆圈就表示图像的每个像素，相连的曲线就表示每一条边，并且这个边还有一个对应的权重。</p><img src="/2018/10/15/medical-image-seg-random-walker/graph.png" class="" title="一种将2维图像用图表达的方式"><!-- ![](./random-walker-algorithm-medical-image-segmentation/graph.png) --><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><p>在基于图的图像分析算法中，权重是一个基本的概念.一般来说,我们用一个函数来表达两个节点之间的权重,从而可以有各种各样的函数来表示它.这里随机游走算法使用的是高斯权重,其表达是如下:</p><p>$$<br>\begin{equation}<br>w_{ij} = exp(- \beta (g_i -g_j)^2)<br>\end{equation}<br>$$</p><p>其中$g_i$表示图像第i个节点处(也就是像素i)的灰度值.</p><p>因此这个权重的意义我们可以理解如下,如果两个相邻像素的灰度值越接近,那么他们之间的权重越大,因此他们之间的联系也就越大.</p><h2 id="Laplacian-Martix-拉普拉斯矩阵"><a href="#Laplacian-Martix-拉普拉斯矩阵" class="headerlink" title="Laplacian Martix (拉普拉斯矩阵)"></a>Laplacian Martix (拉普拉斯矩阵)</h2><p>拉普拉斯矩阵[4]可以反映出一个图的很多有用信息,其定义方式如下.<br>$$<br>\begin{equation}<br>L_{v_{i}v_{j}}=\left{<br>\begin{array}{rcl}<br>d_{v_{i}} &amp; &amp; \text{if i == j}\<br>-w_{ij} &amp; &amp; \text{if $v_i$ and $v_j$ are adjacent}\<br>0 &amp;&amp; \text{otherwise}<br>\end{array} \right.<br>\end{equation}<br>$$</p><p>其中 $d_{v_{i}}$就是公式(1)中的节点$v_{i}$ 的度,$w_{ij}$ 表示节点 $i, j$ 的权重.</p><p>我们可以用一个直观的图像来解释<code>Laplacian Martix</code>的概念,如下图:</p><img src="/2018/10/15/medical-image-seg-random-walker/l-matrix.png" class="" title="Laplacian Martix"><p>一个<code>Laplacian Matrix</code>可以看成是一个<code>Degree Matrix</code>和一个<code>Adjacency Matrix</code>相减得到.<br>$$<br>\begin{equation}<br>L = D - A<br>\end{equation}<br>$$<br>解释一下,从左边第一个图我们可以看出该图一共有<code>6</code>个节点,因此三个矩阵都用一个$6\times 6$的矩阵来表示.</p><ul><li>图像的度矩阵(<code>Degree Matrix</code>)[6]揭示了图中节点的性质,如图左2所示.例如,如果我们将左1图中两个节点中的权重设置为<code>1</code>,那么因为节点<code>5</code>中有三条边从这个节点中止(也就是说有三条边和节点<code>5</code>相连),因此在<code>Degree Matrix</code>为<code>(5, 5)</code>的地方就设置为3,其他节点同理.此时我们结合公式(1)以及图左2就可以理解什么是<code>Degree Matrix</code>了.</li><li>图像的邻接矩阵(<code>Adjacency matrix</code>)[7]解释了两个节点之间的关系.如图右2所示.例如,当节点<code>2</code>和节点<code>1</code>之间有一条连接线时,那么我们就将<code>Adjacency matrix</code>的(1, 2)和(2,1)处设置为1,其他连接线同理类推.不难看出一条性质,就是Adjacency matrix总是沿着对角线对称的.</li><li>结合公式(3)(4)以及下图,我们不难理解图的<code>Laplacian Matrix</code>的概念.</li></ul><h1 id="随机游走算法的思想"><a href="#随机游走算法的思想" class="headerlink" title="随机游走算法的思想"></a>随机游走算法的思想</h1><p>到这里我们提前总结一下随机游走算法的<strong>主要思想</strong>,读者可以读完后面的内容再回来重新回顾这里:<br>随机游走算法将图像分割问题转化成一个随机游走的任务(task)问题,通过将任务建模为一个离散的<code>Dirichlet</code>问题[4]并求解,从而得到分割结果.</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>接下来我将举一个例子来形象的解释一下随机游走算法是怎么工作的[8,9]:</p><img src="/2018/10/15/medical-image-seg-random-walker/1d-demo.png" class="" title="随机游走例子"><p>假设我们有如下任务:一个随即游走者(random walker)的任务是沿着图示的直线运动,每次只能运动相邻的一个整数点.当他在点x(x=1,2,3,4)时,有两种选择,以0.5的概率向左走,或者以0.5的概率向右走.当他走到<code>5</code>点时,认为完成任务,也即到家;当走到<code>0</code>时,认为任务失败,无论走到<code>0</code>还是<code>5</code>,都停止走动.</p><p><strong>问题是: 求这个人在任意一点处到达点<code>5</code>的概率.</strong></p><p>分析:</p><p>设$p(x)$是<code>Random Walker</code>在到达0之前能够到达5的概率,那么$p(x)$具有如下性质:</p><p>$$<br>\begin{equation}<br>p(0) = 0<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>p(5) = 1<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>p(x) = \frac{1}{2}p(x-1) + \frac{1}{2}p(x+1), x=[1,2,3,4]<br>\end{equation}<br>$$<br>公式(5)和(6)表示:如果从0出发,由于直接停止运动,且不可能到达<code>5</code>点,因此概率为0;如果从5出发,直接就达到<code>5</code>点,且停止运动,因此概率为1.</p><p>公式(7)表示<code>Random Walker</code>从任意一个其他点出发,到达<code>5</code>点的概率.这个公式直接看可能有点不好理解,我们可以这样解释它:假设<code>E</code>是事件<code>小人从点x[x=1,2,3,4]到达节点5</code>,<code>F</code>是事件<code>小人从x点先向左走</code>,<code>G</code>是事件<code>小人从x点先向右走</code>,显然F和G是不能同时发生的,且我们从题目中已经知道<code>向左走和向右走的概率分别是0.5</code>,因此有下面的公式:<br>$$<br>\begin{equation}<br>p(E) = p(F)P(E \text{ given } F) + p(G)p(E \text{ given } G)<br>\end{equation}<br>$$<br>对比公式(8),我们不难理解公式(7)的意义.</p><p>结合公式(5-7),我们可以得到下面一组方程:</p><p>$$<br>\begin{equation}<br>p(0) = 0<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>p(1) = \frac{1}{2} p(0) + \frac{1}{2}p(2)<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>p(2) = \frac{1}{2} p(1) + \frac{1}{2}p(3)<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>p(3) = \frac{1}{2} p(2) + \frac{1}{2}p(4)<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>p(4) = \frac{1}{2} p(3) + \frac{1}{2}p(5)<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>p(5) = 1<br>\end{equation}<br>$$</p><p>整理之后如下:<br>$$<br>\begin{bmatrix}<br>1 \<br>1 &amp; -2 &amp; 1 \<br>&amp; 1 &amp; -2 &amp; 1 \<br>&amp; &amp; 1 &amp; -2 &amp; 1 \<br>&amp; &amp; &amp; 1 &amp; -2 &amp; 1 \<br>&amp; &amp; &amp; &amp; &amp; 1<br>\end{bmatrix}</p><p>\begin{bmatrix}<br>p(0) \<br>p(1) \<br>p(2) \<br>p(3) \<br>p(4) \<br>p(5) \<br>\end{bmatrix}<br> =<br>\begin{bmatrix}<br>0 \<br>0 \<br>0 \<br>0\<br>0\<br>1<br>\end{bmatrix}<br>$$</p><p>可见,上述的一个求任意一点到达节点<code>5</code>的概率问题,被我们转化为一个求解一组线性方程组的问题,因为系数矩阵为满秩矩阵,因此方程组必有一组解.</p><h1 id="简单推导"><a href="#简单推导" class="headerlink" title="简单推导"></a>简单推导</h1><h2 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h2><p><strong>注意</strong>:随机游走算法需要事先人为的划定一些点作为标记点,比如,如果我们要在背景中将前景的某个物体分割出来,就必须在背景中选取一个或者一组点,并且在前景也选取一个或一组点作为初始条件.类比上面的例子,就好像我们让$p(0)=0,p(5)=1$一样.否者线性方程组无法求解.</p><p>对于没有标记的点,我们需要分别计算这个点随机在整个图中随机游走的过程中<strong>首次</strong>到达前景和背景的概率,然后取概率大一类的作为该点所属的类别.如下图所示:</p><img src="/2018/10/15/medical-image-seg-random-walker/random-walker.png" class="" title="随机游走算法摘自文献[2]"><p>左上为原始图像,$L_1, L_2, L_3$分别代表人工标记的三个标记点,问号的部分就是没有标记的点. 我们的任务就是根据标记的点,将图像中没有标记的点分割成三部分,其中$L_1, L_2, L_3$分别代表<br>三个部分中的一个代表的点. 和刚才的例子类似,我们需要计算出三张图,即左下,右下,右上这三张图,每张图代表没有标记的点<strong>首次</strong>随机游走到不同标记点的概率,然后取最大的概率对应的label作为该点所属的类别,从而达到分割的目的.</p><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>算法主要优化如下问题:</p><p>$$<br>\begin{equation}<br>Q(x) = \frac{1}{2} x^T L x<br>\end{equation}<br>$$<br>其中<code>x</code>表示待分割图像对应的图向量,<code>L</code>是其对应的拉普拉斯矩阵.</p><p>为了求解公式(15),我们把图上的节点分为两部分,一部分是已经标记的记为$X_M$,另一部分为没有标记的记为$X_U$,并且重新组合拉普拉斯矩阵为如下格式:</p><p>$$<br>L =<br>\begin{bmatrix}<br>L_M &amp; B \<br>B^T &amp; L^U<br>\end{bmatrix}<br>$$<br>则<br>$$<br>\begin{align}</p><p>D(X_U) &amp;= \frac{1}{2} </p><p>\begin{bmatrix}<br>X_M^T &amp; X_U^T<br>\end{bmatrix}</p><p>\begin{bmatrix}<br>L_M &amp; B \<br>B^T &amp; L_U<br>\end{bmatrix}</p><p>\begin{bmatrix}<br>X_M\<br>X_U<br>\end{bmatrix} \</p><p>&amp; = \frac{1}{2} (X_M^T L_M X_M + 2 X_U^T B^T X_M + X_U^T L_U X_U)</p><p>\end{align}<br>$$</p><p><code>D</code>对$X_U$求导并令导数为0,我们可以得到下面的等式:<br>$$<br>\begin{equation}<br>L_U X_U = -B^T X_M<br>\end{equation}<br>$$<br>我们把标记的节点$v_i$和其label<code>s</code>用函数的方式对应起来,即$Q(v_i) = s$,其中<code>s</code>的取值最大为K,K即图像中要分割的区域数.</p><p>令<br>$$<br>\begin{equation}<br>m_i^s=\left{<br>\begin{array}{rcl}<br>1 &amp; &amp; Q(v_i)=s\<br>0 &amp; &amp; Q(v_i)\ne s\<br>\end{array} \right.<br>\end{equation}<br>$$<br>则有:<br>$$<br>\begin{equation}<br>L_U X^s = -B^T m^s<br>\end{equation}<br>$$<br>将s个方程组合到一起,有:<br>$$<br>\begin{equation}<br>L_U X = -B^T M<br>\end{equation}<br>$$</p><p>剩下的任务就是使用优化算法如<code>共轭梯度下降</code>来求解线性方程组(也即公式(21))了.</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上述推导过程只是粗略的把过程写了一下,至于为什么能够把首达问题转化为<code>Dirichlet</code>问题?为什么可以通过优化公式(15)就可以得到分割结果?<code>Laplacian</code>矩阵是如何构建的?以及一些推导的细节问题这里不过多介绍,详情请参考文献[1,2].另外再插一句, 在实现过程中,其核心部分在于构建<code>Laplacian</code>矩阵$L$和矩阵$B$.详情参考<a href="https://github.com/emmanuelle/random_walker" target="_blank" rel="noopener">源码</a>.</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><img src="/2018/10/15/medical-image-seg-random-walker/result.png" class="" title="随机游走算法分割结果"><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] L. Grady and G. Funka-Lea, “Multi-label Image Segmentation for Medical Applications Based on Graph-Theoretic Electrical Potentials,” in Computer Vision and Mathematical Methods in Medical and Biomedical Image Analysis, vol. 3117, M. Sonka, I. A. Kakadiaris, and J. Kybic, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2004, pp. 230–245.</p><p>[2] L. Grady, “Random Walks for Image Segmentation,” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 28, no. 11, pp. 1768–1783, Nov. 2006.</p><p>[3] <a href="https://en.wikipedia.org/wiki/Dirichlet_problem" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dirichlet_problem</a></p><p>[4] [1]L. Grady and E. L. Schwartz, “Anisotropic Interpolation on Graphs: The Combinatorial Dirichlet Problem,” p. 19.</p><p>[5] <a href="https://en.wikipedia.org/wiki/Laplacian_matrix" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Laplacian_matrix</a></p><p>[6] <a href="https://en.wikipedia.org/wiki/Degree_matrix" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Degree_matrix</a></p><p>[7] <a href="https://en.wikipedia.org/wiki/Adjacency_matrix" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Adjacency_matrix</a></p><p>[8] <a href="https://blog.csdn.net/hjimce/article/details/45201263" target="_blank" rel="noopener">Random Walks分割</a></p><p>[9] P. G. Doyle and J. L. Snell, “Random walks and electric networks,” p. 118.</p>]]></content>
      
      
      <categories>
          
          <category> image processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> image processing </tag>
            
            <tag> python </tag>
            
            <tag> medical image segmentation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python:模块</title>
      <link href="/2018/10/13/python-model-and-package/"/>
      <url>/2018/10/13/python-model-and-package/</url>
      
        <content type="html"><![CDATA[<p>简单的说，一个python文件就是一个模块，本文主要介绍以下3点：</p><ul><li><p>模块的建立及导入</p></li><li><p>包的建立及导入</p></li><li><p>发布和安装自定义模块</p></li></ul><a id="more"></a><h1 id="模块的建立及导入"><a href="#模块的建立及导入" class="headerlink" title="模块的建立及导入"></a>模块的建立及导入</h1><p>我们在写c，或者c++时候，为了复用代码，总是将一系列相关的函数写在一个<code>.c</code>文件中，或者封装一个类写在一个<code>.cpp</code>文件中，方便其他程序调用。</p><p>python这里的模块起到同样的作用，我们可以把实现相同任务的一些类和函数写在一个<code>.py</code>文件中，称之为一个模块，方便其它程序调用。</p><h2 id="新建一个模块"><a href="#新建一个模块" class="headerlink" title="新建一个模块"></a>新建一个模块</h2><p>新建一个模块，也就是新建一个<code>.py</code>文件。</p><p>我们新建一个模块<code>utils.py</code>如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py test1和test2是我希望被别人重复利用的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test1-----'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test2-----'</span>)</span><br></pre></td></tr></table></figure><h2 id="导入一个模块"><a href="#导入一个模块" class="headerlink" title="导入一个模块"></a>导入一个模块</h2><p>导入一个模块常用的几种方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="keyword">import</span> utils </span><br><span class="line">utils.test1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> test1</span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> test1, test2</span><br><span class="line">test1()</span><br><span class="line">test2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第四种</span></span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">as</span> u</span><br><span class="line">u.test1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第五种,这种方式建议少用</span></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line">test1()</span><br><span class="line">test2()</span><br></pre></td></tr></table></figure><p>上述方式都可以完成模块的导入，但是最后一种方式不建议使用。<code>因为</code>如果当两个模块中有同名的函数时，后面导入的文件会覆盖掉前面的文件，这是就很难分清到底使用的是哪个模块中的方法了。</p><p>举个实际中的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread, imsave</span><br></pre></td></tr></table></figure><p>无论是新建一个模块和导入一个模块看起来都不难，接下来介绍一些需要注意的事情。</p><h2 id="模块中的-name"><a href="#模块中的-name" class="headerlink" title="模块中的__name__"></a>模块中的__name__</h2><p><strong>当一个程序导入另一个模块时，实际上会把这个模块从头到尾执行一遍。</strong> </p><p>这样就带来个一个问题：一般情况下，我在模块中为了测试每个函数的功能是否正常，需要添加一些测试的程序，如果不把这些程序去除，在被其它程序导入时就会执行了这些程序，显然这是我们不希望看到的。</p><p><code>__name__</code>的使用在不删除模块内测试代码的前提下解决了上述问题。我们先来做个测试，在<code>utils.py</code>模块中打印一个变量<code>__name__</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test1-----'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test2-----'</span>)</span><br><span class="line"></span><br><span class="line">print(__name__)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> utils <span class="comment"># 注意，这里我除了导入模块之外其他什么也没做</span></span><br><span class="line">             <span class="comment"># 由于导入模块时会把整个模块文件执行一遍，因此会直接调用print(__name__)这句话。</span></span><br></pre></td></tr></table></figure><p>当我执行如下两条命令时，请注意<code>__name__</code>的值是如何变化的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; python utils.py</span><br><span class="line">&gt;&gt;&gt; __main__</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; python main.py</span><br><span class="line">&gt;&gt;&gt; utils</span><br></pre></td></tr></table></figure><p>通过上述执行过程我们可以看出，当执行<code>utils.py</code>文件时，<code>__name__</code>的值为<code>&#39;_main__&#39;</code>,当执行<code>main.py</code>时，<code>utils.py</code>里面<code>__name__</code>的值为<code>&#39;utils&#39;</code>。因此我们只需要在<code>utils.py</code>的测试代码中加上如下代码即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test1-----'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test2-----'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    test1()</span><br><span class="line">    print(__name__)</span><br></pre></td></tr></table></figure><p>上述判断语句添加完之后，当再有其他程序导入<code>utils</code>模块时，就不会执行<code>utils</code>里面测试代码的部分了。当直接执行<code>utils.py</code>文件时，才会执行测试代码的部分。</p><p>我们总结一下，一般来说，一个标准一点的<code>python</code>程序具有如下的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>  xxxx</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main() <span class="comment">#注意这里的main()和c语言中的不一样，只是借用了C语言中的语境，表达一个程序的开始而已。</span></span><br></pre></td></tr></table></figure><h2 id="模块中的-all"><a href="#模块中的-all" class="headerlink" title="模块中的__all__"></a>模块中的__all__</h2><p>再回顾一下我们的<code>utils.py</code>模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py test1和test2是我希望被别人重复利用的代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test1-----'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test2-----'</span>)</span><br></pre></td></tr></table></figure><hr><p>上述模块在使用<code>from utils import *</code>的方式被导入时候，所有的函数都会被导入，<strong>如果我不希望部分函数被外部使用，而只是公开我想要给大家使用的代码，可以使用<code>__all__</code>变量来完成</strong>，其使用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># utils.py</span></span><br><span class="line">__all__ = [<span class="string">'TestClass'</span>, <span class="string">'test1'</span>] <span class="comment"># 这里把函数，类的名字当成一个元素放在列表里。</span></span><br><span class="line">                                 <span class="comment"># 当其他函数使用from utils import *时，只能访问到`__all__`变量里面的内容</span></span><br><span class="line">                                 <span class="comment"># 这里test2函数就不能被其他模块使用了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test1-----'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----test2-----'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>此时当<code>main.py</code>再次调用<code>utils</code>模块时候，就不能访问<code>test2</code>函数了。测试如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: test1()</span><br><span class="line">-----test1--------</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: test2()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-3</span><span class="number">-35</span>ebc1c532fc&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 test2()</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">'test2'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: TestClass()</span><br><span class="line">Out[<span class="number">4</span>]: &lt;utils.TestClass at <span class="number">0x7fcf5055ae90</span>&gt;</span><br></pre></td></tr></table></figure><hr><blockquote><blockquote><p>一个需要注意的地方是：<code>__all__</code>变量只用来约束<code>from xxx import *</code>的形式,而其他形式还是可以正常调用的。</p></blockquote></blockquote><p>如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: <span class="keyword">from</span> utils <span class="keyword">import</span> test2</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: test2()</span><br><span class="line">------test2--------</span><br></pre></td></tr></table></figure><h1 id="包的建立及导入"><a href="#包的建立及导入" class="headerlink" title="包的建立及导入"></a>包的建立及导入</h1><p>如果想快速了解使用方法，请直接看<a href="##2.4">总结部分</a>。</p><h2 id="包的建立"><a href="#包的建立" class="headerlink" title="包的建立"></a>包的建立</h2><p>为了将具有相关联功能的模块放在一起管理，将这些模块放在同一个文件夹下。<br>比如有<code>sengMsg.py</code>和<code>revMsg.py</code>两个模块，由于他们都是和消息相关的模块，因此我用<code>msg</code>文件夹来把它们放在一起。如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg/</span><br><span class="line">├── revMsg.py</span><br><span class="line">└── sendMsg.py</span><br></pre></td></tr></table></figure><p>此时我们还不能直接通过<code>import</code>的方式直接使用msg这两个模块。比如<code>import msg</code>是无法使用里面的模块的。</p><blockquote><blockquote><p>注意：<code>在python3</code>中，直接调用<code>import msg</code>不会出错，但是却无法导入模块并使用模块里面的功能。</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> msg</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: msg.revMsg.test1()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-2</span><span class="number">-4</span>c1d6211c490&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 msg.revMsg.test1()</span><br><span class="line"></span><br><span class="line">AttributeError: module <span class="string">'msg'</span> has no attribute <span class="string">'revMsg'</span></span><br></pre></td></tr></table></figure><blockquote><blockquote><p>在<code>python2</code>中，即使是调用<code>import msg</code>也会直接报错，因为它们都将<code>msg</code>当做一个普通的文件夹处理</p></blockquote></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2</span></span><br><span class="line">[<span class="number">1</span>]: <span class="keyword">import</span> msg</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ImportError                               Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-12</span><span class="number">-40</span>dac918f9d8&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 import msg</span><br><span class="line"></span><br><span class="line">ImportError: No module named msg</span><br></pre></td></tr></table></figure><h2 id="init-py文件"><a href="#init-py文件" class="headerlink" title="__init__.py文件"></a>__init__.py文件</h2><p>为了解决上述问题,需要在<code>msg</code>文件夹下新建一个<code>__init__.py</code>,告诉python解释器不要把<code>msg</code>当成一个普通的文件夹处理，而当做一个<strong>包</strong>对待。</p><blockquote><blockquote><p>注意：<code>python3</code>在没有<code>__init__.py</code>文件时已经默认<code>msg</code>是一个包，因此上面一段话仅对<code>python2</code>来说有用。</p></blockquote></blockquote><p>此时我们可以认为<strong>含有一个<code>__init__.py</code>文件，并且具有很多模块的一个文件夹，这个整体叫做包</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msg/</span><br><span class="line">├── __init__.py</span><br><span class="line">├── revMsg.py</span><br><span class="line">└── sendMsg.py</span><br></pre></td></tr></table></figure><p>此时，我们就可以直接导入里面的模块了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> msg <span class="keyword">import</span> revMsg</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: revMsg.test1()</span><br><span class="line">----test1 revMsg----</span><br></pre></td></tr></table></figure><p>但是如果通过如下方式导入时即</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> msg</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: msg.sengMsg.test1()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-2</span>-be5fc6eec2f7&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 msg.sengMsg.test1()</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">'module'</span> object has no attribute <span class="string">'sengMsg'</span></span><br></pre></td></tr></table></figure><p>还是无法导入。和模块一样，当一个包被导入的时候，里面的<code>__init__.py</code>文件会被执行一遍，因此需要在里面添加如下内容，从而使得我们能够去除掉述导包时出现的错误：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> (sendMsg, revMsg) <span class="comment"># 这种方式是python2和python3兼容的，因此建议使用这种方式。</span></span><br></pre></td></tr></table></figure><p>此时就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> msg</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: msg.revMsg.test1()</span><br><span class="line">----test1 revMsg----</span><br></pre></td></tr></table></figure><h2 id="all-变量"><a href="#all-变量" class="headerlink" title="__all__变量"></a>__all__变量</h2><p>和模块中的<code>__all__</code>变量一样，我们可以在<code>__init__.py</code>中写入<code>__all__ = [&#39;xxx&#39;, &#39;xxx&#39;]</code>的形式定义<code>import *</code>时候可以使用哪些模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __init__.py</span></span><br><span class="line">__all__ = [<span class="string">'revMsg'</span>]</span><br></pre></td></tr></table></figure><p>此时通过<code>from msg import *</code>方式导入模块只能是<code>revMsg</code>模块。</p><blockquote><blockquote><p>注意：<code>__all__</code>变量同样不会影响<code>from msg.sendMsg import test1</code>等类似方式的调用。只会影响到<code>import *</code>方式的调用。</p></blockquote></blockquote><blockquote><blockquote><p><strong>我们总结一个<code>__init__.py</code>文件下最好有两个内容：</strong></p><ol><li><code>__all__</code>变量指定<code>from xxx import *</code>时候可以使用哪些模块。</li><li><code>from .xx import (xxx, xxxx, xxxx)</code>的内容，指定其他时候可以使用哪些模块。</li></ol></blockquote></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于模块和包的创建以及导入我们总结如下：</p><ol><li><p>一个<code>xx.py</code>文件被称为一个模块。</p></li><li><p>将实现相关联功能的模块放在一起，再添加一个<code>__init__.py</code>文件，放在一个文件夹中，称之为一个包。</p></li><li><p><code>__all__</code>变量在模块中可以定义导入该模块时使用<code>from xx import *</code>时导入模块内的哪些内容。</p></li><li><p><code>__all__</code>变量在<code>__init__.py</code>文件中可以定义使用<code>from xx import *</code>时导入哪些模块。</p></li><li><p>当导入模块时，模块的对应文件会被从头到尾执行一遍，因此需要使用<code>__name__</code>变量的性质屏蔽掉测试代码。</p></li><li><p>当导入包时，里面的<code>__init__.py</code>文件会从头到尾被执行一遍，因此可以在这里加上导包的命令使得当一个程序导入该包时可以导入包里面的模块。</p></li><li><p>当然<code>__init__.py</code>也可以是一个空文件，只不过此时不能通过只导一个包的形式(<code>import xxx</code>)来调用包里面的模块(<code>xxx.xxx_model</code>).</p></li></ol><p>最后我们在来看一个<code>skimage</code>中的其中一个包是怎么写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xxx/site-packages/skimage/segmentation/__init__.py</span></span><br><span class="line"><span class="keyword">from</span> .random_walker_segmentation <span class="keyword">import</span> random_walker <span class="comment">#表示从当前文件夹下的random_walker_segmentation模块中导入random_walker函数</span></span><br><span class="line"><span class="keyword">from</span> .active_contour_model <span class="keyword">import</span> active_contour</span><br><span class="line"><span class="keyword">from</span> ._felzenszwalb <span class="keyword">import</span> felzenszwalb</span><br><span class="line"><span class="keyword">from</span> .slic_superpixels <span class="keyword">import</span> slic</span><br><span class="line"><span class="keyword">from</span> ._quickshift <span class="keyword">import</span> quickshift</span><br><span class="line"><span class="keyword">from</span> .boundaries <span class="keyword">import</span> find_boundaries, mark_boundaries</span><br><span class="line"><span class="keyword">from</span> ._clear_border <span class="keyword">import</span> clear_border</span><br><span class="line"><span class="keyword">from</span> ._join <span class="keyword">import</span> join_segmentations, relabel_from_one, relabel_sequential</span><br><span class="line"><span class="keyword">from</span> ..morphology <span class="keyword">import</span> watershed <span class="comment"># 表示从上一层路径下的morphology包中导入watershed模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当使用from segmentation import *时，下面这些函数可以被使用</span></span><br><span class="line">__all__ = [<span class="string">'random_walker'</span>， </span><br><span class="line">           <span class="string">'active_contour'</span>,</span><br><span class="line">           <span class="string">'felzenszwalb'</span>,</span><br><span class="line">           <span class="string">'slic'</span>,</span><br><span class="line">           <span class="string">'quickshift'</span>,</span><br><span class="line">           <span class="string">'find_boundaries'</span>,</span><br><span class="line">           <span class="string">'mark_boundaries'</span>,</span><br><span class="line">           <span class="string">'clear_border'</span>,</span><br><span class="line">           <span class="string">'join_segmentations'</span>,</span><br><span class="line">           <span class="string">'relabel_from_one'</span>,</span><br><span class="line">           <span class="string">'relabel_sequential'</span>,</span><br><span class="line">           <span class="string">'watershed'</span>]</span><br></pre></td></tr></table></figure><h1 id="发布和安装自定义模块"><a href="#发布和安装自定义模块" class="headerlink" title="发布和安装自定义模块"></a>发布和安装自定义模块</h1><p>这里只介绍一种通过<code>setup.py</code>文件制作包的方式，不能通过<code>pip</code>或<code>conda</code>命令安装，但是基本上对于目前的应用来说已经够用了。因此其他方式不再介绍。</p><h2 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h2><ol><li><p>首先确保包的目录结构如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── msg</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── revMsg.py</span><br><span class="line">│   └── sendMsg.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure></li><li><p>然后编辑<code>setup.py</code>文件如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"></span><br><span class="line">setup(name = <span class="string">'xuyangcao'</span>, </span><br><span class="line">        version = <span class="string">'1.0'</span>, </span><br><span class="line">        description = <span class="string">'xuyangcao\'s model'</span>,</span><br><span class="line">        author = <span class="string">'xuyangcao'</span>,</span><br><span class="line">        py_modules = [<span class="string">'msg.sendMsg'</span>, <span class="string">'msg.revMsg'</span>])</span><br></pre></td></tr></table></figure></li><li><p>build<br> 执行<code>setup.py</code>构建模块，命令如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py build</span><br></pre></td></tr></table></figure><p> 执行后其目录结构变化如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── msg</span><br><span class="line">│           ├── __init__.py</span><br><span class="line">│           ├── revMsg.py</span><br><span class="line">│           └── sendMsg.py</span><br><span class="line">├── msg</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── revMsg.py</span><br><span class="line">│   └── sendMsg.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p> 发现build 文件夹下的东西就是原始文件夹里面内容的一个拷贝。</p></li><li><p>sdist<br> <code>build</code>结束后，再执行如下命令：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py sdist</span><br></pre></td></tr></table></figure><p> 运行完之后目录结构如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    .</span><br><span class="line">├── build</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── msg</span><br><span class="line">│           ├── __init__.py</span><br><span class="line">│           ├── revMsg.py</span><br><span class="line">│           └── sendMsg.py</span><br><span class="line">├── dist</span><br><span class="line">│   └── xuyangcao-1.0.tar.gz</span><br><span class="line">├── MANIFEST</span><br><span class="line">├── msg</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── revMsg.py</span><br><span class="line">│   └── sendMsg.py</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p> 我们需要的东西就在<code>./dist</code>下面的压缩包里。</p></li></ol><h2 id="发布与安装"><a href="#发布与安装" class="headerlink" title="发布与安装"></a>发布与安装</h2><p><strong>发布</strong>: </p><p>将<code>./dist/xuyangcao-1.0.tar.gz</code>解压，发布到需要的地方即可。</p><p><strong>安装</strong></p><p>这个应该是比较熟悉的了，我们安装其他第三方模块时肯定也用过这种方式。</p><p>解压缩压缩包里的文件，其目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── msg</span><br><span class="line">│           ├── __init__.py</span><br><span class="line">│           ├── revMsg.py</span><br><span class="line">│           └── sendMsg.py</span><br><span class="line">├── msg</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── revMsg.py</span><br><span class="line">│   └── sendMsg.py</span><br><span class="line">├── PKG-INFO</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p>接下来就可以安装了，直接输入我们熟悉的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>大功告成！</p><h2 id="测试一下吧"><a href="#测试一下吧" class="headerlink" title="测试一下吧"></a>测试一下吧</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> msg</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: msg.revMsg.test1()</span><br><span class="line">----test1 revMsg----</span><br></pre></td></tr></table></figure><p>成功！ </p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python:实例属性和类属性</title>
      <link href="/2018/10/08/learn-python-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/10/08/learn-python-%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>我们常写的<code>python</code>代码中如果给一个对象增加一个属性，比如给一个<code>Student</code>类增加一个<code>name</code>属性，那么可以直接在<code>__init__(self, name)</code>增加一个<code>self.name = name</code>即可。这样每新建一个对象，就会有一个对应的<code>name</code>属性与之对应，且对象之间的<code>name</code>是不共享的。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><p>然而有时候我们希望<strong>让所有新建出来的对象共享同样的一个属性</strong>，这时候就需要用到<code>类属性</code>的概念了。在面向对象的语言中，我们总是说一切皆对象，因此可以把我们新定义的类看做一个类对象，这样给类添加的属性叫做类属性。其表现形式为如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 属性</span></span><br><span class="line">    num = <span class="number">0</span>                     <span class="comment"># 类属性</span></span><br><span class="line">    <span class="comment"># 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name        <span class="comment"># 实例属性</span></span><br></pre></td></tr></table></figure><p>举个类比的例子，<strong><code>类属性</code>的作用有点像<code>全局变量</code></strong>：我们为了让全局范围内都能够访问一个变量，可以定义一个全局变量；而为了让所有的对象都能够访问同一个变量，就可以定义一个类属性来满足需求。</p><a id="more"></a><h1 id="新建一个对象的机制"><a href="#新建一个对象的机制" class="headerlink" title="新建一个对象的机制"></a>新建一个对象的机制</h1><p>当一个类定义完成后，一但创建一个该类的实例对象，该实例保存了两样东西：</p><ol><li>实例属性，也就是我们通过<code>__init()__</code>方法给它的一些属性(通常我们都是这么做的)。在对象之间不可以共享。</li><li>一个特殊的属性，知道该实例是通过那个类创建的。（这样做的好处是没有保存该类的各种方法，而是只在类中定义了一份，以节省空间）</li></ol><p>从上面的分析来看，一个类为了保存各种方法，因此也是要内存空间的，因此一个<strong><code>类对象</code></strong>也可以包含两样东西：</p><ol><li>类属性，可以在对象之间共享。</li><li>各种方法</li></ol><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><h2 id="类属性归类所有"><a href="#类属性归类所有" class="headerlink" title="类属性归类所有"></a>类属性归类所有</h2><p>还是以<code>Student</code>为例，我们有如下需求：</p><blockquote><p>每新实例化一个<code>Student</code>类都有一个计数器来记录当前已经创建了多少个对象了.</p></blockquote><p>因此可以使用类属性做到这个需求,代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Student.num += <span class="number">1</span>        <span class="comment"># 注意这里使用的不是self.num,而是Student.num</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_num</span><span class="params">(self, )</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Student.num      <span class="comment"># 注意这里使用的不是self.num,而是Student.num </span></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">'xiaoming'</span>)</span><br><span class="line">print(s1.get_num())</span><br><span class="line"></span><br><span class="line">s2 = Student(<span class="string">'xiaohong'</span>)</span><br><span class="line">print(s2.get_num())</span><br><span class="line"></span><br><span class="line">s3 = Student(<span class="string">'huluwa'</span>)</span><br><span class="line">print(s3.get_num())</span><br><span class="line"></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>从输出的结果可以看出，所有的对象都是共享类属性的。</p><h2 id="类属性可以通过实例对象调用"><a href="#类属性可以通过实例对象调用" class="headerlink" title="类属性可以通过实例对象调用"></a>类属性可以通过实例对象调用</h2><p>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        Student.num += <span class="number">1</span>        <span class="comment"># 注意这里使用的不是self.num,而是Student.num</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_num</span><span class="params">(self, )</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Student.num      <span class="comment"># 注意这里使用的不是self.num,而是Student.num </span></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">'xiaoming'</span>)</span><br><span class="line">print(s1.num)                   <span class="comment"># 这里直接通过对象访问类属性依然可以访问到</span></span><br><span class="line"></span><br><span class="line">s2 = Student(<span class="string">'xiaohong'</span>)</span><br><span class="line">print(s2.num)</span><br><span class="line"></span><br><span class="line">s3 = Student(<span class="string">'huluwa'</span>)</span><br><span class="line">print(s3.num)</span><br><span class="line"></span><br><span class="line"><span class="comment">#---</span></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong><em>注意：</em></strong> </p><blockquote><p>类属性和实例属性尽量不要用同样的名字，否则通过对象调用类属性时，会被相同名字的实例属性覆盖。详情见[1].</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，我们可以总结实例属性和类属性有如下特点：</p><ul><li><p>实例属性：<br>  和具体的某个实力对象有关系，并且一个实例对象和另一个实例对象是不共享属性的。</p></li><li><p>类属性：<br>  类属性所属于类对象，并且多个实例对象之间共享同一个类属性。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">[1.]廖雪峰python</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim配置python相关插件</title>
      <link href="/2018/10/06/vim%E9%85%8D%E7%BD%AEpython%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/"/>
      <url>/2018/10/06/vim%E9%85%8D%E7%BD%AEpython%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>以下所有配置均在ubuntu16.04下安装完成：</p><a id="more"></a><h1 id="配置vim插件管理工具"><a href="#配置vim插件管理工具" class="headerlink" title="配置vim插件管理工具"></a>配置vim插件管理工具</h1><p>常用的vim插件管理工具有两个，一个是<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">vim-pathogen</a>另一个是<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle.vim</a>.</p><h2 id="配置vim-pathogen"><a href="#配置vim-pathogen" class="headerlink" title="配置vim-pathogen"></a>配置vim-pathogen</h2><p>对比了一下两个工具，这里我选择的是<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">vim-pathogen</a>,其配置过程简单描述如下，详细信息直接参考官网就可以了：</p><ul><li><p>首先在<code>~/.vim</code>下创建两个文件夹，一个是autoload，另一个是bundle，以后所有的插件应用都安装在bundle中。然后下载pathogen到autoload下面。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~/.vim/<span class="built_in">autoload</span> ~/.vim/bundle &amp;&amp; \</span><br><span class="line">$ curl -LSso ~/.vim/<span class="built_in">autoload</span>/pathogen.vim https://tpo.pe/pathogen.vim</span><br></pre></td></tr></table></figure></li><li><p>配置<code>.vimrc</code>,在<code>.vimrc</code>添加如下代码：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ execute pathogen<span class="comment">#infect()</span></span><br><span class="line">$ syntax on</span><br><span class="line">$ filetype plugin indent on</span><br></pre></td></tr></table></figure></li><li><p>基本配置完上述内容就可以使用了，详情请参考<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="noopener">文档</a>。</p></li></ul><h2 id="配置vimogen"><a href="#配置vimogen" class="headerlink" title="配置vimogen"></a>配置vimogen</h2><p><a href="https://github.com/rkulla/vimogen" target="_blank" rel="noopener">vimogen</a>结合上面的pathogen使得安装插件更加容易，只要在一个固定的文件<code>.vimogen_repos</code>中添加上插件的github地址，然后就可以使用命令自动安装。在安装好pathogen之后，添加如下代码即可：</p><ul><li><p>安装</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/rkulla/vimogen</span><br><span class="line">$ chmod u+x vimogen</span><br><span class="line">$ cp vimogen to your <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>使用<br>首先将想要安装软件的地址放在<code>~/.vimogen_repos</code>里面，像下面这样：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Valloric/YouCompleteMe</span><br><span class="line">https://github.com/jeaye/color_coded</span><br><span class="line">https://github.com/rdnetto/YCM-Generator</span><br><span class="line">https://github.com/scrooloose/nerdtree</span><br><span class="line">https://github.com/Shougo/neocomplete.vim</span><br></pre></td></tr></table></figure><p>  然后执行<code>vimogen</code>：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vimogen</span><br></pre></td></tr></table></figure><p>  安装界面如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) INSTALL</span><br><span class="line">2) UNINSTALL</span><br><span class="line">3) UPDATE</span><br><span class="line">4) EXIT</span><br><span class="line">Enter the number of the menu option to perform:</span><br></pre></td></tr></table></figure><p>  直接按<code>1</code>就可以了，程序会自动安装上面链接里面的插件，如果已经安装，则会跳过。<br>  如果按<code>2</code>，则是卸载已经安装的插件，直接选择要卸载的插件对应的编号即可。</p></li></ul><h1 id="配置常用插件"><a href="#配置常用插件" class="headerlink" title="配置常用插件"></a>配置常用插件</h1><h2 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h2><p><a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">YouCompleteMe</a>基本上支持各种语言的自动补全，其安装过程需要编译一下，因此这里介绍一下安装过程，后面的几个插件因为直接使用vimogen装上就可以直接使用，因此不在过多介绍后面几类插件。<code>YCM</code>安装过程如下：</p><ul><li><p>下载<br>  直接使用<a href="##配置vimogen">vimogen一节</a>介绍的方法讲<code>YCM</code>下载到<code>~/.vim/bundle</code>中，然后进入到<code>~/.vim/bundle/YouCompleteMe/</code>路径下。</p></li><li><p>安装<br>  按照自己的需求选择编译命令，这里我因为常用的是python，但是也把c-family语言也选上了，因此执行下面命令进行编译安装：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vim/bundle/YouCompleteMe</span><br><span class="line">python3 install.py --clang-completer</span><br><span class="line"><span class="comment"># 注意：如果编译开始时出错一般是缺少各种工具，按照提示安装就可以了。</span></span><br></pre></td></tr></table></figure></li><li><p>配置<br>  这里根据自己的需求配置一些常用参数在<code>.vimrc</code>中。<br>  我配置的如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;==================YCM====================</span><br><span class="line">let g:ycm_global_ycm_extra_conf = &apos;~/.vim/bundle/YouCompleteMe/.ycm_extra_conf.py&apos;</span><br><span class="line">nnoremap &lt;F12&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br></pre></td></tr></table></figure><p>  配置的第二行配置了一个快捷键用来使用<code>F12</code>实现go to definition的功能。</p><p>  自动补全的效果如下：</p>  <img src="/2018/10/06/vim%E9%85%8D%E7%BD%AEpython%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/ycm.png" class="">  <img src="/2018/10/06/vim%E9%85%8D%E7%BD%AEpython%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/ycm2.png" class=""></li></ul><h2 id="neocomplete-vim"><a href="#neocomplete-vim" class="headerlink" title="neocomplete.vim"></a>neocomplete.vim</h2><p><a href="https://github.com/Shougo/neocomplete.vim" target="_blank" rel="noopener">neocomplete.vim</a>实现路径的自动补全功能，效果如下：</p><img src="/2018/10/06/vim%E9%85%8D%E7%BD%AEpython%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/neocomplete.png" class=""><h2 id="nerdtree"><a href="#nerdtree" class="headerlink" title="nerdtree"></a>nerdtree</h2><p><a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">nerdtree</a>实现在左侧目录树功能，其效果如下：</p><img src="/2018/10/06/vim%E9%85%8D%E7%BD%AEpython%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6/tree.png" class=""><h1 id="vimrc"><a href="#vimrc" class="headerlink" title=".vimrc"></a>.vimrc</h1><p>最后把常用的<code>.vimrc</code>文件配置贴出来用于以后使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&quot;===============pathogen=================</span><br><span class="line">execute pathogen#infect()</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">&quot;===============基本设置=================</span><br><span class="line">set number              &quot;显示行号</span><br><span class="line">set ruler               &quot;打开状态栏标尺</span><br><span class="line">syntax on               &quot;自动语法高亮 </span><br><span class="line">set shiftwidth=4        &quot;默认缩进4个空格 </span><br><span class="line">set softtabstop=4       &quot;使用tab时 tab空格数 </span><br><span class="line">set tabstop=4           &quot;tab 代表4个空格  </span><br><span class="line">set expandtab         &quot;使用空格替换tab</span><br><span class="line">set showmatch           &quot;高亮显示匹配的括号</span><br><span class="line">set hlsearch            &quot;高亮显示搜索结果</span><br><span class="line"></span><br><span class="line">&quot;===============nerdtree=================</span><br><span class="line">autocmd StdinReadPre * let s:std_in=1</span><br><span class="line">autocmd VimEnter * if argc() == 1 &amp;&amp; isdirectory(argv()[0]) &amp;&amp; !exists(&quot;s:std_in&quot;) | exe &apos;NERDTree&apos; argv()[0] | wincmd p | ene | endif &quot;当没指定文件时nerdtree自动打开</span><br><span class="line">map &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt; </span><br><span class="line">autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif &quot;当只剩下nerdtree时候vim自动退出</span><br><span class="line"></span><br><span class="line">&quot;==================YCM====================</span><br><span class="line">let g:ycm_global_ycm_extra_conf = &apos;~/.vim/bundle/YouCompleteMe/.ycm_extra_conf.py&apos;</span><br><span class="line">nnoremap &lt;F12&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">&quot;nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习python：关于函数的参数</title>
      <link href="/2018/10/04/%E5%AD%A6%E4%B9%A0python%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/"/>
      <url>/2018/10/04/%E5%AD%A6%E4%B9%A0python%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>大体上python中的参数可以根据其表现形式分为以下四种：</p><ol><li>位置参数</li><li>默认参数</li><li>关键字参数</li><li>可变参数</li></ol><p>其中前两种是比较常用的方式，其形式也c，c++等语言形式上比较相似，因此比较好理解。</p><p>关键字参数也是非常常用的方式，使用关键字参数不需要使传入的参数顺序和函数定义的参数顺序一致，因此更加灵活，尤其是参数过多的时候。</p><p>可变参数的形式用处也十分广泛，其表现形式有两种，分别是使用一个<code>*</code>和两个<code>**</code>来表示，且星号所处位置不同(分定义函数时和调用函数)，其功能也有所差异。虽然这样，这种方式也不难理解，只需要多加练习即可。</p><p>在实际应用过程中，前三种方式最为常用，但是往往也会看到很多人使用后可变参数的方式进行程序的编写，因此学会并且掌握所有的参数的使用方法是十分必要的。</p><a id="more"></a><h1 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h1><p><strong>位置参数</strong>和我们使用的c，c++等语言中定义和调用方法一致。且在调用函数的时候传入的参数顺序要和定义时候的顺序一致，其主要表现形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(num1, num2)</span>:</span></span><br><span class="line">    print(num1)</span><br><span class="line">    print(num2)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="comment">#Output:</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>由于位置参数比较简单，因此这里不在过多介绍。</p><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><strong>默认参数</strong>是指在我们定义函数的过程中，如果有一些参数大多数情况下都可以使用一个值，那么就可以给它一个默认的值，或者是给它一个初始的值。</p><p>这样的话当我再调用一个这个函数的时候，如果我给它传递一个值，那么函数就会收到我给它传递的值；否则，如果我没有给它传递值，那么函数也不会报错，而是使用默认的值作为参数。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(num, power=True)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> power:</span><br><span class="line">        print(num ** <span class="number">2</span>) </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(num)</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>)                <span class="comment"># 第一个参数由于是位置参数，因此必须传入值</span></span><br><span class="line">                    <span class="comment"># 但是第二个参数由于有了默认值，因此可以不给它传值，此时使用默认的值</span></span><br><span class="line">f(<span class="number">2</span>, <span class="literal">True</span>)          <span class="comment"># 当然也可以给它附上一个值，注意此时没给它关键字信息，它会自动把`True`这个值匹配给函数中的power</span></span><br><span class="line">f(<span class="number">2</span>, <span class="literal">False</span>)         <span class="comment"># 同上</span></span><br><span class="line">f(<span class="number">2</span>, power=<span class="literal">False</span>)   <span class="comment"># 当然还可以使用`power=xxx`的方式去给这个参数传值</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>上一节<a href="#默认参数">默认参数</a>的最后,实际上已经用到了关键字参数的形式，<code>f(2, power=False)</code>中<code>power=False</code>这样以一个key=value的形式来传递参数的方式即为关键字参数。和位置参数不同，关键字参数不需要使传入的参数顺序和定义的顺序相同，因为它是通过关键字去匹配的，如下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    print(<span class="string">'a = %d'</span>%a)</span><br><span class="line">    print(<span class="string">'b = %d'</span>%b)</span><br><span class="line">    print(<span class="string">'c = %d'</span>%c)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)<span class="comment"># 使用位置参数，1， 2， 3分别对应a, b, c</span></span><br><span class="line">f(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)<span class="comment"># 使用关键字参数，也可以让传入参数顺序和定义顺序相同</span></span><br><span class="line">f(b=<span class="number">2</span>, c=<span class="number">3</span>, a=<span class="number">1</span>)<span class="comment"># 使用关键字参数，还可以使传入参数顺序和定义顺序不同</span></span><br><span class="line">f(c=<span class="number">3</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)<span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><h2 id="一个-的表现形式-包裹位置参数"><a href="#一个-的表现形式-包裹位置参数" class="headerlink" title="一个*的表现形式(包裹位置参数)"></a>一个*的表现形式(包裹位置参数)</h2><p>所谓的包裹(packing)位置参数,就是在函数执行过程中，将传入的多余的位置参数打包为一个tuple传入包裹位置参数中。</p><p>一个经典的例子就是：<code>如何将传递到函数里的参数全部相加，而且传入函数中的参数数量不确定</code>。比如如果我传入1，2,那么就要输出3，如果输入1, 2, 3, 4，就是要输出10.</p><p>这时我们就可以使用可变参数来解决这个问题，其函数定义方式为<code>f(*args)</code>。注意，其中的<code>args</code>参数名字可以换为其它的名字，但是为了方便阅读和协作开发，我们通常使用<code>args</code>来表示一个可变参数。</p><p>这种形式当放在函数的定义中时，会把调用时多余的位置参数传递给args，并且封装为一个tuple。</p><p>我们可以通过如下的方式实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        sum += i</span><br><span class="line">    print(sum)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(num, *args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    sum += num </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        sum += i</span><br><span class="line">    print(sum)</span><br><span class="line"></span><br><span class="line">f()             <span class="comment"># 可以看到，当可变参数什么都传递时，程序不会挂掉，而是在’args‘中收到一个空的tuple</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)         <span class="comment"># 当传入1，2时，函数接收到了两个参数到args中，并且形式为一个tuple</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)   <span class="comment"># 同上，只不过tuple中的元素个数变为了4个，即args = (1, 2, 3, 4)</span></span><br><span class="line">print(<span class="string">'---'</span>)</span><br><span class="line">f1(<span class="number">1</span>)           <span class="comment"># 这个例子中，由于只传递了一个参数，而函数中又有位置参数，因此args中为空</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>)        <span class="comment"># 这个例子中， 由于有两个参数，因此把多余的2传递到args中，即args = (2)</span></span><br><span class="line">f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 这个例子中， 由于多了三个参数，因此把多余的</span></span><br><span class="line">                <span class="comment"># 3个参数都给到args中，即args = （2， 3， 4）</span></span><br><span class="line">---</span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line">()</span><br><span class="line"><span class="number">0</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">---</span><br><span class="line">()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">(<span class="number">2</span>,)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="两个-的表现形式-包裹关键字参数"><a href="#两个-的表现形式-包裹关键字参数" class="headerlink" title="两个**的表现形式(包裹关键字参数)"></a>两个**的表现形式(包裹关键字参数)</h2><p>所谓的包裹关键字参数，就是函数执行时将传入的多余关键字参数打包成一个dict，然后传递给一个固定的参数。</p><p>其函数定义的方式为<code>f(**kwargs)</code>。注意，其中参数kwargs的名字也是可以替换成任意名字的，只不过还是为了协作开发以及阅读的方便，我们约定俗成使用<code>kwargs</code>。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">f(name = <span class="string">'laowang'</span>, age = <span class="number">30</span>)<span class="comment"># 函数中没有位置参数，因此直接将关键字参数打包为一个字典传给kwargs，注意，我们在使用时不加两个`**`,直接使用`print(kwargs)`即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Output </span></span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">30</span>, <span class="string">'name'</span>: <span class="string">'laowang'</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(name, age, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">'name = %s'</span> % name)</span><br><span class="line">    print(<span class="string">'age = %d'</span> % age)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">f(name = <span class="string">'laowang'</span>, age = <span class="number">30</span>)<span class="comment"># 当程序中有了位置参数时候，首先把传入的值给到位置参数</span></span><br><span class="line"><span class="comment"># 如果没有多余的值，kwargs为空 </span></span><br><span class="line">f(name = <span class="string">'laoli'</span>, age = <span class="number">30</span>, name1 = <span class="string">'huluwa'</span>, age1 = <span class="number">80</span>)        <span class="comment"># 当程序中有了多余的关键字参数，才将多余的部分传递给kwargs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line">name = laowang</span><br><span class="line">age = <span class="number">30</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">name = laoli</span><br><span class="line">age = <span class="number">30</span></span><br><span class="line">&#123;<span class="string">'age1'</span>: <span class="number">80</span>, <span class="string">'name1'</span>: <span class="string">'huluwa'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>前面说道，<code>*</code>和<code>**</code>在函数中和调用时的使用方式是不一样的，我们已经知道在函数中他们起到打包(packing)的作用；自然可以推理一下在函数调用过程中它们应该是起到解包（unpacking）的作用。</p><p>首先看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def f(*args, **kwargs):</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">    print(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">a = (1, 2, 3)</span><br><span class="line">b = &#123;&apos;name&apos;:&apos;laowang&apos;, &apos;age&apos;:30&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3, name=&apos;laowang&apos;, age=30)# 直接按照上两节讲的内容,将1,2,3打包成位置参数，将name和age打包成关键字参数</span><br><span class="line">f(a, b)# 这里由于a和b虽然其内容一个是tuple一个是dict，但是放在参数里都被当做了位置参数处理，而kwargs里面为空</span><br><span class="line"></span><br><span class="line"># Output </span><br><span class="line">(1, 2, 3)</span><br><span class="line">&#123;&apos;age&apos;: 30, &apos;name&apos;: &apos;laowang&apos;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">((1, 2, 3), &#123;&apos;age&apos;: 30, &apos;name&apos;: &apos;laowang&apos;&#125;)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子我们可以看出，我们希望让<code>f(a, b)</code>的调用方式能够和<code>f(1, 2, 3, name=&#39;laowang&#39;, age=30)</code>的调用方式得到相同的结果，但是却失败了。</p><p>原因是<code>**kwargs</code>只接受key=value形式的调用，而我们直接调用<code>f(a, b)</code>, 虽然<code>b={&#39;name&#39;:&#39;laowang&#39;, &#39;age&#39;:30}</code>是一个字典，但是放在传入参数中时候b就变成了一个元素，因此没有达到我们想要的效果；变量a同理。</p><p>解决上述问题就是在调用时候增加一个解包(unpacking)的标识符即对应的<code>*</code>和<code>**</code>号。如将上述调用方式改为<code>f(*a, **b)</code>,这样其效果就等同于调用<code>f(1, 2, 3, name=&#39;laowang&#39;, age=30)</code>,也就是说，<code>*</code>和<code>**</code>号把对应的tuple或者dict中的元素一个一个解包出来了。</p><p>demo如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line">    print(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">'name'</span>:<span class="string">'laowang'</span>, <span class="string">'age'</span>:<span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, name=<span class="string">'laowang'</span>, age=<span class="number">30</span>)</span><br><span class="line">f(*a, **b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output </span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">30</span>, <span class="string">'name'</span>: <span class="string">'laowang'</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">30</span>, <span class="string">'name'</span>: <span class="string">'laowang'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="python-中参数的注意事项"><a href="#python-中参数的注意事项" class="headerlink" title="python 中参数的注意事项"></a>python 中参数的注意事项</h1><p>一个需要注意的问题就是顺序问题，一个合法的顺序是<code>位置参数-&gt;默认参数-&gt;包裹位置参数(*)-&gt;包裹关键字参数(**)</code>。见下面的demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c=<span class="number">10</span>, *args, **kwargs)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(c)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">num = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">info = &#123;<span class="string">'name'</span>:<span class="string">'huluwa'</span>, <span class="string">'grade'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">100</span>, <span class="number">10</span>, <span class="number">20</span>, *num, **info)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output </span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">'grade'</span>: <span class="number">2</span>, <span class="string">'name'</span>: <span class="string">'huluwa'</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learn kalman-filter (学习卡尔曼滤波)</title>
      <link href="/2018/07/12/kalman-filter/"/>
      <url>/2018/07/12/kalman-filter/</url>
      
        <content type="html"><![CDATA[<p>&lt;未完结…&gt;</p><p>基本上把现有的kalman滤波的各种参考资料全部看了一遍,发现国内的博客一个特点,就是各种搬移,弄得最后大家也分不清到底谁是原创,当然了我自己也有这样的问题,这篇文章也仅仅是把别人写的好的东西借鉴过来,再加上一点自己的理解而已,其目的是当自己以后再使用或者给别人讲解的时候不用再去重新查找.</p><a id="more"></a><p>到目前为止我也认为老外写的<a href="http://bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener">这篇文章[3]</a>是最直观易懂的,本文里的公式以及各种符号也准备全部采用自这篇文章,以统一各种符号.</p><p>本文主要从以下几个方面讲解,首先用大家经常讲的两个例子来说明一下kalman滤波的主要思想; 然后从公式推倒方面详细讲解一下kalman滤波的过程;最后用一个实例来展示一下kalman 滤波的效果.</p><hr><h1 id="直观理解"><a href="#直观理解" class="headerlink" title="直观理解"></a>直观理解</h1><p>网上例子很多,这里讲了两个,一个是<strong>测量室内温度</strong>的例子, 另一个是<strong>小机器人走路</strong>的例子,我个人比较喜欢第二个例子,因为和我做的东西比较相似,而且用物理公式来表示其预测方程是我们比较熟悉的.</p><h2 id="测量温度的例子"><a href="#测量温度的例子" class="headerlink" title="测量温度的例子"></a>测量温度的例子</h2><p>最常见的例子就是测量室内温度的例子: </p><p>假设你来到了一间屋子, 想知道当前时间屋子里的确切温度, 看了一下屋子里记录的温度发现上一个小时的温度是23度,那如果粗略估计一下温度的话,我们发现室内环境相对比较稳定, 因此此时的温度和上一小时的温度应该差不多,所以就估计一个23度好了, 如果你对温度精度的要求不高的话,这个估计的温度就可以将就着用了;</p><p>现在你的需求变了,希望估计的温度稍微准确一点,怎么办呢? 我们发现正常情况下,室外的温度在一天情况下14:00温度最高,14:00之前温度呈上升趋势,14:00之后温度呈下降趋势.比如我随便找了一点北京海淀区的气温图如下:</p><img src="/2018/07/12/kalman-filter/temperature.png" class="" width="500"><p>好了,刚才我们找到的规律是气温24小时恒定不变,然后根据上一小时的温度估计了现在的温度也是23度;现在我们找到的这个规律比上一个规律更合理,因此我可以按照这个新的规律重新猜测, 如果我当前时间在14点以前,那我就认为当前温度比上一小时热一点,比如我猜测当前为24度; 相反,如果我当前时间在14点以前,那我就猜的温度低一点,比如22度.显然在正常情况下我们认为这样预测更为合理(还得有个假设是室内的温度会收到室内的影响,我们假设和室外规律差不多吧).</p><p>现在老板给了你一个数字的温度计(我记得初中刚开始学模拟和数字量的时候很晕,还不知道什么是数字信号什么是模拟信号,哈哈),并且告诉你这个数字温度计不准,可能有一定误差,让你更加精确地测量室内温度.</p><p>如果老板没有告诉你温度计不准,那我们将就着用就是了,毕竟温度计会比人准一些.但是老板的意图显然不是这样,他想让你把温度计带来的这部分不确定性也给去掉. 这怎么办呢?</p><p>kalman滤波想解决的就是权衡你的估计值和温度计测量的值之间的比重,把二者中不准的部分去掉,准确的部分留下,有点取其精华,去其糟粕的感觉. 你现在有了一个估计的值,我们还假设是23度吧,结果数字温度计测量的25度, 那我们觉得自己估计的没有温度计测量的准确,因此可能估计的值偏小了;但是温度计的也不是完全准确,因此可能温度计测量的值偏大了,那我们权衡一下两者之间的值就好了! 通过计算我们发现24.56度更加接近真实的值,这个值更加接近25度,因为我们觉得温度计比我们估计的更准一些,因此计算出来的值更偏向温度计测量值.</p><p>至于这个24.56度是怎么算出来的我认为初学者不需要关注,先建立其一个直观上的感觉再说,计算的问题我们留在第二节去研究.</p><h2 id="小机器人走路的例子"><a href="#小机器人走路的例子" class="headerlink" title="小机器人走路的例子"></a>小机器人走路的例子</h2><p>小机器人走路的例子最早在参考资料<strong>[3]</strong> 里面的内容中发现: </p><p>假设我们设计了一个小机器人, 让它在小树林里执行任务. 我们想知道小机器人在某一时刻的精确状态,在这里我们设状态包括小机器人的<strong>速度</strong>和<strong>位置</strong>信息. 小机器人身上带了个GPS,还可以通过GPS定位和时间差计算出来当前速度,但遗憾的是这个GPS精度只有10m,因此如果机器人只依赖GPS导航的话,可能前面5m有个大坑小机器人都看不见,直接勇敢的跳下去,估摸着也就GG了.此处应该有配图:</p><img src="/2018/07/12/kalman-filter/robot.png" class="" title="小机器人以身殉职.jpg"><p>因此像上面温度的例子一样,除了从传感器获取信息之外,我们依然可以用一组状态方程去描述小机器人的运动行为,然后结合我们预测的状态和传感器测量的状态,得到一个更加准确的结果:</p><p>最简单的方法就是我们可以假设小机器人在很短的$\Delta t$时间段内是做的匀速直线运动,这样我们高中物理学的那个经典公式就派上用场了:</p><p>$$<br>\begin{split}<br>{p_k} &amp;= {p_{k-1}} + \Delta t &amp;{v_{k-1}} \<br>{v_k} &amp;= &amp;{v_{k-1}}<br>\end{split}<br>$$</p><p>其中: $p$代表位置信息(position), $v$代表速度信息(velocity).</p><p>这样我们就有了状态的迭代过程,即可以从上一状态推测出当前状态,再权衡一下传感器得到的状态,即可以得到kalman 滤波的结果, 很完美!</p><p>那么问题来了: <strong>kalman 滤波过程是如何权衡预测状态和观测状态的呢?</strong> 这个是下一节我们要讲的问题.</p><hr><h1 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h1><p>在开始简单的推导之前,我觉得有必要普及一些基本概念,包括<a href="https://en.wikipedia.org/wiki/Covariance_matrix" target="_blank" rel="noopener">协方差矩阵(Covariance matrix)</a> 以及 融合高斯分布(Combining Gaussians)</p><h2 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h2><p>对于一个一维随机变量$X$来说,我们可以用均值$\mu$和方差$\delta$来表示其统计特性.拿一个高斯分布来说,均值$\mu$决定了其概率密度曲线的对称轴,方差$\delta$决定了样本的离散程度,在概率密度函数上影响着其图形的’胖瘦’.</p><p>而<strong>协方差矩阵</strong>和上述的$\delta$类似,影响着多维随机变量的分布特性.</p><p>对于一个$n$维的随机向量$\mathbf{X}$来说, 可以用如下式子表示:</p><p>$$<br>\begin{align}<br>\mathbf{X} =<br>\begin{bmatrix}<br>X_1 \<br>X_2 \<br>\cdots \<br>X_n \<br>\end{bmatrix}<br>\end{align}<br>$$</p><p>其中$X_i$表示随机向量里面的一个元素, 举个例子, 比如我们要区别两种鱼的种类:三文鱼和鳗鱼,取长度,宽度,颜色亮度三个特征进行分类,那么这三个量就分别是$X_1, X_2, X_3$, 他们共同组成了随机向量$\mathbf{X}$.</p><p>好了,对于随机向量$\mathbf{X}$, 其协方差矩阵中的元素定义如下:</p><p>$$ \Sigma_{ij} = Cov(X_i, Y_j) = E[(X_i - \mu_i)(X_j - \mu_j)] $$</p><p>$$ \mu_i = E(X_i) $$</p><p>协方差矩阵因此可以写成下面的一个矩阵形式:</p><p>$$<br>\begin{equation}<br>\Sigma =<br>\begin{bmatrix}<br>E[(X_1 - \mu_1)(X_1 - \mu_1)] &amp; E[(X_1 - \mu_1)(X_2 - \mu_2)] &amp; \cdots &amp; E[(X_1 - \mu_1)(X_n - \mu_n)] \<br>E[(X_2 - \mu_2)(X_1 - \mu_1)] &amp; E[(X_2 - \mu_2)(X_2 - \mu_2)] &amp; \cdots &amp; E[(X_2 - \mu_2)(X_n - \mu_n)] \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>E[(X_n - \mu_n)(X_1 - \mu_1)] &amp; E[(X_n - \mu_n)(X_2 - \mu_2)] &amp; \cdots &amp; E[(X_n - \mu_n)(X_n - \mu_n)] \<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>从上面的公式中可以看出,当协方差矩阵中只有对角线上的元素时,随机变量之间没有相关性,当对角线元素上的权重越大,说明随机变量之间的相关性越强.下图显示了二维随机向量中两个分量的相关性是怎么影响样本的分布规律的.</p><img src="/2018/07/12/kalman-filter/GaussianScatterPCA.png" class="" width="400" title="高斯分布PCA"><h2 id="融合高斯分布"><a href="#融合高斯分布" class="headerlink" title="融合高斯分布"></a>融合高斯分布</h2><p>我们拿1维的两个高斯分布为例,说明一下把他们的概率密度相乘之后表示的意思:</p><p>1维高斯分布概率密度函数如下:</p><p>$$<br>\begin{equation} \label{gaussformula}<br>N(x, \mu,\sigma) = \frac{1}{ \sigma \sqrt{ 2\pi } } e^{ -\frac{ (x – \mu)^2 }{ 2\sigma^2 } }<br>\end{equation}<br>$$</p><p>对于两个分布, $N(x, \color{fuchsia}{\mu_0}, \color{deeppink}{\sigma_0})$ 和 $N(x, \color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\sigma_1})$, 将两个随机的概率密度相乘,如下:</p><p>\begin{equation} \label{gaussequiv}<br>\mathcal{N}(x, \color{fuchsia}{\mu_0}, \color{deeppink}{\sigma_0}) \cdot \mathcal{N}(x, \color{yellowgreen}{\mu_1}, \color{mediumaquamarine}{\sigma_1}) \stackrel{?}{=} \mathcal{N}(x, \color{royalblue}{\mu’}, \color{mediumblue}{\sigma’})<br>\end{equation}</p><p>结合公式 \eqref{gaussformula}和 \eqref{gaussequiv},可以得到如下的表达形式:<br>$$<br>\begin{equation} \label{fusionformula}<br>\begin{aligned}<br>\color{royalblue}{\mu’} &amp;= \mu_0 + \frac{\sigma_0^2 (\mu_1 – \mu_0)} {\sigma_0^2 + \sigma_1^2}\<br>\color{mediumblue}{\sigma’}^2 &amp;= \sigma_0^2 – \frac{\sigma_0^4} {\sigma_0^2 + \sigma_1^2}<br>\end{aligned}<br>\end{equation}<br>$$</p><img src="/2018/07/12/kalman-filter/gauss_joint.png" class="" width="300"><p>我们把上式中的公共部分提取出来叫$k$,则:<br>$$<br>\begin{equation} \label{gainformula}<br>\color{purple}{\mathbf{k}} = \frac{\sigma_0^2}{\sigma_0^2 + \sigma_1^2}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{split}<br>\color{royalblue}{\mu’} &amp;= \mu_0 + &amp;\color{purple}{\mathbf{k}} (\mu_1 – \mu_0)\<br>\color{mediumblue}{\sigma’}^2 &amp;= \sigma_0^2 – &amp;\color{purple}{\mathbf{k}} \sigma_0^2<br>\end{split} \label{update}<br>\end{equation}<br>$$</p><p>好了,我们把上式再扩展到多维情况,<br>$$<br>\begin{equation} \label{matrixgain}<br>\color{purple}{\mathbf{K}} = \Sigma_0 (\Sigma_0 + \Sigma_1)^{-1}<br>\end{equation}<br>$$<br>$$<br>\begin{equation}<br>\begin{split}<br>\color{royalblue}{\vec{\mu}’} &amp;= \vec{\mu_0} + &amp;\color{purple}{\mathbf{K}} (\vec{\mu_1} – \vec{\mu_0})\<br>\color{mediumblue}{\Sigma’} &amp;= \Sigma_0 – &amp;\color{purple}{\mathbf{K}} \Sigma_0<br>\end{split} \label{matrixupdate}<br>\end{equation}<br>$$</p><p>其中这个 $K$就是我们听到过的那个名词,<strong>kalman增益</strong>.</p><p>接下来一节我们看一下这个kalman增益是如何被应用到滤波中去的.</p><h2 id="以小机器人为例"><a href="#以小机器人为例" class="headerlink" title="以小机器人为例"></a>以小机器人为例</h2><p>$$<br>\begin{equation} \label{eq:statevars}<br>\begin{aligned}<br>\mathbf{\hat{x}}<em>k &amp;= \begin{bmatrix}<br>\text{position}\<br>\text{velocity}<br>\end{bmatrix}\<br>\mathbf{P}_k &amp;=<br>\begin{bmatrix}<br>\Sigma</em>{pp} &amp; \Sigma_{pv} \<br>\Sigma_{vp} &amp; \Sigma_{vv} \<br>\end{bmatrix}<br>\end{aligned}<br>\end{equation}<br>$$</p><p>$$<br>\begin{split}<br>\color{deeppink}{p_k} &amp;= \color{royalblue}{p_{k-1}} + \Delta t &amp;\color{royalblue}{v_{k-1}} \<br>\color{deeppink}{v_k} &amp;= &amp;\color{royalblue}{v_{k-1}}<br>\end{split}<br>$$</p><p>$$<br>\begin{align}<br>\color{deeppink}{\mathbf{\hat{x}}<em>k} &amp;= \begin{bmatrix}<br>1 &amp; \Delta t \<br>0 &amp; 1<br>\end{bmatrix} \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} \<br>&amp;= \mathbf{F}<em>k \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} \label{statevars}<br>\end{align}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{split}<br>Cov(x) &amp;= \Sigma\<br>Cov(\color{firebrick}{\mathbf{A}}x) &amp;= \color{firebrick}{\mathbf{A}} \Sigma \color{firebrick}{\mathbf{A}}^T<br>\end{split} \label{covident}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{split}<br>\color{deeppink}{\mathbf{\hat{x}}<em>k} &amp;= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} \<br>\color{deeppink}{\mathbf{P}<em>k} &amp;= \mathbf{F_k} \color{royalblue}{\mathbf{P}</em>{k-1}} \mathbf{F}_k^T<br>\end{split}<br>\end{equation}<br>$$</p><p>$$<br>\begin{split}<br>\color{deeppink}{p_k} &amp;= \color{royalblue}{p_{k-1}} + {\Delta t} &amp;\color{royalblue}{v_{k-1}} + &amp;\frac{1}{2} \color{darkorange}{a} {\Delta t}^2 \<br>\color{deeppink}{v_k} &amp;= &amp;\color{royalblue}{v_{k-1}} + &amp; \color{darkorange}{a} {\Delta t}<br>\end{split}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{split}<br>\color{deeppink}{\mathbf{\hat{x}}<em>k} &amp;= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} + \begin{bmatrix}<br>\frac{\Delta t^2}{2} \<br>\Delta t<br>\end{bmatrix} \color{darkorange}{a} \<br>&amp;= \mathbf{F}<em>k \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} + \mathbf{B}_k \color{darkorange}{\vec{\mathbf{u}_k}}<br>\end{split}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{split}<br>\color{deeppink}{\mathbf{\hat{x}}<em>k} &amp;= \mathbf{F}_k \color{royalblue}{\mathbf{\hat{x}}</em>{k-1}} + \mathbf{B}<em>k \color{darkorange}{\vec{\mathbf{u}_k}} \<br>\color{deeppink}{\mathbf{P}_k} &amp;= \mathbf{F_k} \color{royalblue}{\mathbf{P}</em>{k-1}} \mathbf{F}_k^T + \color{mediumaquamarine}{\mathbf{Q}_k}<br>\end{split}<br>\label{kalpredictfull}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>\vec{\mu}<em>{\text{expected}} &amp;= \mathbf{H}_k \color{deeppink}{\mathbf{\hat{x}}_k} \<br>\mathbf{\Sigma}</em>{\text{expected}} &amp;= \mathbf{H}_k \color{deeppink}{\mathbf{P}_k} \mathbf{H}_k^T<br>\end{aligned}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{aligned}<br>\mathbf{H}_k \color{royalblue}{\mathbf{\hat{x}}_k’} &amp;= \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} &amp; + &amp; \color{purple}{\mathbf{K}} ( \color{yellowgreen}{\vec{\mathbf{z}_k}} – \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \<br>\mathbf{H}_k \color{royalblue}{\mathbf{P}_k’} \mathbf{H}_k^T &amp;= \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} &amp; – &amp; \color{purple}{\mathbf{K}} \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T}<br>\end{aligned} \label {kalunsimplified}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation} \label{eq:kalgainunsimplified}<br>\color{purple}{\mathbf{K}} = \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{split}<br>\color{royalblue}{\mathbf{\hat{x}}_k’} &amp;= \color{fuchsia}{\mathbf{\hat{x}}_k} &amp; + &amp; \color{purple}{\mathbf{K}’} ( \color{yellowgreen}{\vec{\mathbf{z}_k}} – \color{fuchsia}{\mathbf{H}_k \mathbf{\hat{x}}_k} ) \<br>\color{royalblue}{\mathbf{P}_k’} &amp;= \color{deeppink}{\mathbf{P}_k} &amp; – &amp; \color{purple}{\mathbf{K}’} \color{deeppink}{\mathbf{H}_k \mathbf{P}_k}<br>\end{split}<br>\label{kalupdatefull}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\color{purple}{\mathbf{K}’} = \color{deeppink}{\mathbf{P}_k \mathbf{H}_k^T} ( \color{deeppink}{\mathbf{H}_k \mathbf{P}_k \mathbf{H}_k^T} + \color{mediumaquamarine}{\mathbf{R}_k})^{-1}<br>\label{kalgainfull}<br>\end{equation}<br>$$</p><h1 id="仿真实验"><a href="#仿真实验" class="headerlink" title="仿真实验"></a>仿真实验</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]. <a href="https://cnblogs.com/xmphoenix/p/3634536.html" target="_blank" rel="noopener">(csdn) 对Kalman(卡尔曼)滤波器的理解</a><br>[2]. <a href="https://blog.csdn.net/u010720661/article/details/63253509" target="_blank" rel="noopener">(csdn) 详解卡尔曼滤波原理</a><br>[3]. <a href="http://bzarg.com/p/how-a-kalman-filter-works-in-pictures/" target="_blank" rel="noopener">How a Kalman filter works, in pictures</a></p>]]></content>
      
      
      <categories>
          
          <category> pattern recognation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pattern recognation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大恒水星相机硬触发测试</title>
      <link href="/2018/06/28/daheng-camera/"/>
      <url>/2018/06/28/daheng-camera/</url>
      
        <content type="html"><![CDATA[<p>大恒水星相机硬触发测试：</p><p>c++实现：</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSampleCaptureEventHandler</span> :</span> <span class="keyword">public</span> ICaptureEventHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoOnImageCaptured</span><span class="params">(CImageDataPointer&amp;objImageDataPointer, <span class="keyword">void</span>* pUserParam)</span> <span class="comment">//回调函数处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"收到一帧图像!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ImageInfo: "</span> &lt;&lt; objImageDataPointer-&gt;GetStatus() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ImageInfo: "</span> &lt;&lt; objImageDataPointer-&gt;GetWidth() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ImageInfo: "</span> &lt;&lt; objImageDataPointer-&gt;GetHeight() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ImageInfo: "</span> &lt;&lt; objImageDataPointer-&gt;GetPayloadSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//声明事件回调对象指针</span></span><br><span class="line">IDeviceOfflineEventHandler* pDeviceOfflineEventHandler = <span class="literal">NULL</span>;<span class="comment">///&lt;掉线事件回调对象</span></span><br><span class="line">IFeatureEventHandler* pFeatureEventHandler = <span class="literal">NULL</span>;<span class="comment">///&lt;远端设备事件回调对象</span></span><br><span class="line">ICaptureEventHandler* pCaptureEventHandler = <span class="literal">NULL</span>;<span class="comment">///&lt;采集回调对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">IGXFactory::GetInstance().Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举设备</span></span><br><span class="line">gxdeviceinfo_vector vectorDeviceInfo;</span><br><span class="line">IGXFactory::GetInstance().UpdateDeviceList(<span class="number">1000</span>, vectorDeviceInfo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == vectorDeviceInfo.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"无可用设备!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反初始化库</span></span><br><span class="line">IGXFactory::GetInstance().Uninit();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开第一台设备以及设备下面第一个流</span></span><br><span class="line">CGXDevicePointer ObjDevicePtr = </span><br><span class="line">        IGXFactory::GetInstance().OpenDeviceBySN(vectorDeviceInfo[<span class="number">0</span>].GetSN(), GX_ACCESS_EXCLUSIVE);</span><br><span class="line">CGXStreamPointer ObjStreamPtr = ObjDevicePtr-&gt;OpenStream(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取远端设备属性控制器</span></span><br><span class="line">CGXFeatureControlPointer ObjFeatureControlPtr = ObjDevicePtr-&gt;GetRemoteFeatureControl();</span><br><span class="line">ObjFeatureControlPtr-&gt;GetEnumFeature(<span class="string">"TriggerMode"</span>)-&gt;SetValue(<span class="string">"On"</span>);</span><br><span class="line">ObjFeatureControlPtr-&gt;GetEnumFeature(<span class="string">"TriggerSource"</span>)-&gt;SetValue(<span class="string">"Line0"</span>);</span><br><span class="line">ObjFeatureControlPtr-&gt;GetEnumFeature(<span class="string">"TriggerActivation"</span>)-&gt;SetValue(<span class="string">"RisingEdge"</span>);</span><br><span class="line">ObjFeatureControlPtr-&gt;GetFloatFeature(<span class="string">"TriggerDelay"</span>)-&gt;SetValue(<span class="number">500000</span>);</span><br><span class="line">ObjFeatureControlPtr-&gt;GetFloatFeature(<span class="string">"TriggerFilterRaisingEdge"</span>)-&gt;SetValue(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册回调采集</span></span><br><span class="line">pCaptureEventHandler = <span class="keyword">new</span> CSampleCaptureEventHandler();</span><br><span class="line">ObjStreamPtr-&gt;RegisterCaptureCallback(pCaptureEventHandler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送开采命令</span></span><br><span class="line">ObjStreamPtr-&gt;StartGrab();</span><br><span class="line">ObjFeatureControlPtr-&gt;GetCommandFeature(<span class="string">"AcquisitionStart"</span>)-&gt;Execute();</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送停采命令</span></span><br><span class="line">ObjFeatureControlPtr-&gt;GetCommandFeature(<span class="string">"AcquisitionStop"</span>)-&gt;Execute();</span><br><span class="line">ObjFeatureControlPtr-&gt;GetEnumFeature(<span class="string">"TriggerMode"</span>)-&gt;SetValue(<span class="string">"Off"</span>);</span><br><span class="line"></span><br><span class="line">ObjStreamPtr-&gt;StopGrab();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注销采集回调</span></span><br><span class="line">ObjStreamPtr-&gt;UnregisterCaptureCallback();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">ObjStreamPtr-&gt;Close();</span><br><span class="line">ObjDevicePtr-&gt;Close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//反初始化库</span></span><br><span class="line">IGXFactory::GetInstance().Uninit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁事件回调指针</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != pCaptureEventHandler)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> pCaptureEventHandler;</span><br><span class="line">pCaptureEventHandler = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果图：</p><img src="/2018/06/28/daheng-camera/hard.png" class="" width="800">]]></content>
      
      
      <categories>
          
          <category> image processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> image processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习sklearn:非参数估计之 kernel density estimation (核密度估计)</title>
      <link href="/2018/06/27/kernel-density-estimation/"/>
      <url>/2018/06/27/kernel-density-estimation/</url>
      
        <content type="html"><![CDATA[<p>在概率密度估计过程中，如果我们队随机变量的分布是已知的，那么可以直接使用参数估计的方法进行估计，如最大似然估计方法。</p><p>然而在实际情况中，随机变量的参数是未知的,因此需要进行非参数估计.核密度估计是非参数估计的一种方法，也就是大家经常听见的parzen 窗方法了.</p><p>本文主要介绍 <strong>非参数估计的过程</strong>以及 <strong>parzen窗方法估计概率密度的过程.</strong></p><a id="more"></a><h1 id="非参数估计"><a href="#非参数估计" class="headerlink" title="非参数估计"></a>非参数估计</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><img src="/2018/06/27/kernel-density-estimation/pdf.png" class="" width="500" title="图1"><p>如图1所示，对于一个未知的概率密度函数$p(x)$,某一个随机变量$x$落在区域$R$里的概率可以表示成如下形式：</p><p>$$P = \int_{R} P(x^{‘}) dx^{‘} （１）$$</p><p>如果$R$足够窄，我们可以用$P$来表示$p(x)$的一个平均后的结果。假设我们现在有$n$个样本，<br>且他们服从独立同分布，那么$n$个样本中的$k$个落在区域$R$中的概率可以表示成下面的公式：</p><p>$$ P_k = C_n^k P^k (1-P)^{n-k}　　（２）$$</p><p>由上面的公式我们可以得到$k$的期望为：</p><p>$$ E(k) = n \cdot P　　（３）$$</p><p>同时，当$n$足够大时，我们可以近似地认为$\frac{k}{n}$可以作为$P$的一个近似值。</p><p>然后，假设$n$足够大，$R$足够小，并且假设$p(x)$是连续的，那么我们可以得到：</p><p>$$\int_{R} P(x^{‘}) dx^{‘} \approx p(x) \cdot V 　（４）$$</p><p>其中$x$是区域$R$中的一个点，$V$是$R$的面积(体积)，结合上述4个式子，得：</p><p>$$ p(x)V = \int_{R} p(x^{‘}) dx^{‘} = P = \frac{E(k)}{n} 　（５）$$<br>$$ \therefore p(x) = \frac{E(k)}{n \cdot V} \approx \frac{k}{n \cdot V}　　（６）$$</p><p>因此，某一小区域内的概率密度函数就可以用上述公式表示了。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们再看一下公式（６）:</p><p>$$ p(x) \approx \frac{k/n}{V} \approx \frac{P}{V} = \frac{\int_{R} p(x^{‘})d{x^{‘}}}{\int_{R}dx{‘}}　　（７）$$</p><p>显然我们估计的这个概率密度是一个平滑的结果,即当$V$选择的越大,估计的结果和真实结果相比就越平滑;因此看起来我们需要把$V$设置的小一点,然而如果我们把$V$选择的过小,也会出现问题:太小的$V$会导致这块小区域里面没有一个点落在里面,因此就会得到该点的概率密度为0;另外,假设刚好有一个点落在了这个小区域里,那由于V过于小,我们计算得到的概率密度可能也会趋近于无穷,两个结果对于我们来说都是没有太大意义的．</p><p>从 <strong>实际的角度</strong>来看，我们获取的数据量一定是有限的，因此体积$V$不可能取到无穷小，我们可以总结下，使用非参数概率密度估计有以下两方面限制，且是不可避免的：</p><ol><li><strong><em>在有限数据下，使用非参数估计方法计算的概率密度一定是真实概率密度平滑后的结果.</em></strong></li><li><strong><em>在有限数据下，体积趋于无穷小计算的概率密度没有意义．</em></strong></li></ol><p>从 <strong>理论的角度</strong>来看，我们希望知道如果有无限多的采样数据，那么上述两个限制条件应该怎样克服？假设我们使用下面的方法来估计点 $x$ 处的概率密度: 构造一系列包含 $x$ 的区域 $R_1, R_2, … R_n$,　其中 $R_1$ 中包含一个样本，$R_n$中包含 $n$ 个样本．则：</p><p>$$ p_n(x) = \frac{k_n / n}{V_n}  （８）$$</p><p>其中$ｐ_n(x)$表示第$n$次估计结果，如果要求$p_n(x)$能够收敛到$p(x)$,则需要满足下面三个条件：</p><ul><li><p>$\lim_{n \rightarrow \infty} V_n = 0$</p></li><li><p>$ \lim_{n \rightarrow \infty} k_n = \infty$</p></li><li><p>$ \lim_{n \rightarrow \infty} k_n / n = 0$ </p></li></ul><h1 id="parzen窗法"><a href="#parzen窗法" class="headerlink" title="parzen窗法"></a>parzen窗法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>假设$R_n$是一个$d$维的超立方体(hypercube),且其边长为$h$, 那么我们可以用如下公式表示$V_n$:</p><p>$$V_n = h_n^d       （９）$$</p><p>然后我们再定义一个窗函数（window function）:</p><p>$$ \varphi (u) =<br>\begin{cases}<br>1  \quad |u_j| \leq 1/2 \<br>0  \quad otherwise<br>\end{cases} \quad(10)$$</p><p>$\varphi$ 定义了一个以圆点为中心的单位超立方体,这样我们就可以用$\varphi$来表示体积$V$内的样本个数:</p><p>$$k_n = \sum_{i=1}^{n} \varphi(\frac{x - x_i}{h_n}) \quad(11)$$</p><p>好了,有了$k_n$和$V_n$,直接把他们带入公式(6),我们可以得到parzen窗法的计算公式:<br>$$ p_n(x) = \frac{1}{n} \sum_{i=1}^{n} \frac{1}{V_n} \varphi(\frac{x - x_i}{h_n}) \quad(12)$$</p><blockquote><p>我们发现这个$\varphi$不仅可以是上述的单位超立方体的形式,只要其满足如下两个约束就可以,因此也就出现了各种各样更能表现样本属性的窗函数,比如用的非常多的高斯窗.</p><ol><li>$\varphi(x) \geq 0$</li><li>$\int \varphi(u)du = 1$</li></ol></blockquote><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>网上经常会见到这样的解释: <strong>某一点的概率密度是其他样本点在这一点的概率密度分布的平均值</strong>.还有这样一张图:</p><img src="/2018/06/27/kernel-density-estimation/his_parzen.png" class="" width="400" title="图2"><p>上面一句话可以这样解释:<br>我们定义核函数:<br>$$\delta(x) = \frac{1}{V_n} \varphi(\frac{x}{h_n}) \quad(13)$$</p><p>那么某一点$x$的概率密度可以用如下函数来表示:<br>$$p_n(x) = \frac{1}{n} \sum_{i=1}^{n} \delta_{n}(x - x_i) \quad(14)$$</p><p>从公式(13)(14)我们可以看出,当$h_n$很大的时候,$\delta_n(x)$就是一个 <strong>矮胖</strong>的函数,由公式(14)将每个样本点在点$x$处的贡献取平均之后,点$x$处的概率密度就是一个非常平滑的结果; 当$h_n$太小的时候,$\delta_n(x)$就是一个 <strong>高瘦</strong>的函数,由公式(14)将每个样本点在点$x$处的贡献取平均之后,点$x$处的概率密度就是一个受噪声影响非常大的值,因此估计的概率密度平滑性就很差,反而和真实值差的很远.这两点和1.2节总结的两点缺陷正好吻合.</p><h2 id="仿真实验"><a href="#仿真实验" class="headerlink" title="仿真实验"></a>仿真实验</h2><p>如下我做了两个仿真</p><ol><li>第一个是生成了均值是0，方差是2的服从高斯分布的数据，分别使用bandwidth为0.1, 1, 5三个值进行估计</li><li>第二个是生成了100个服从高斯混合分布的数据，分别是均值为0，方差为1以及均值为5，方差为1的两个高斯混合模型，两者相互独立。</li></ol><p>这里核函数选的是高斯核。</p><p>bandwidth = 0.1 | bandwidth = 1 | bandwidth = 5<br>:-: | :-:</p><img src="/2018/06/27/kernel-density-estimation/0.1-1.png" class="" width="300"> | <img src="/2018/06/27/kernel-density-estimation/1-1.png" class="" width="300"> | <img src="/2018/06/27/kernel-density-estimation/5-1.png" class="" width="300"><p>bandwidth = 0.1 | bandwidth = 0.5 | bandwidth = 1<br>:-: | :-:</p><img src="/2018/06/27/kernel-density-estimation/0.1-2.png" class="" width="300"> | <img src="/2018/06/27/kernel-density-estimation/0.5-2.png" class="" width="300"> | <img src="/2018/06/27/kernel-density-estimation/1-2.png" class="" width="300"><p>可以很明显得看到估计的概率密度是如何受到bandwidth影响的，当bandwidth选择的太小，则估计的密度函数受到噪声影响很大，这种结果是不能用的；当bandwidth选择过大，则估计的概率密度又太过于平滑。总之，无论bandwidth过大还是过小，其结果都和实际情况相差的很远，因此合理地选择bandwidth是很重要的。</p><p>下面是高斯混合分布密度估计的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors.kde <span class="keyword">import</span> KernelDensity</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    x = np.concatenate((np.random.normal(<span class="number">0</span>, <span class="number">1</span>, int(<span class="number">0.3</span>*<span class="number">100</span>)), np.random.normal(<span class="number">5</span>, <span class="number">1</span>, int(<span class="number">0.7</span>*<span class="number">100</span>))))[:, np.newaxis]</span><br><span class="line">    plot_x = np.linspace(<span class="number">-5</span>, <span class="number">10</span>, <span class="number">1000</span>)[:, np.newaxis]</span><br><span class="line">    true_dens = <span class="number">0.3</span>*norm(<span class="number">0</span>, <span class="number">1</span>).pdf(plot_x) + <span class="number">0.7</span>*norm(<span class="number">5</span>, <span class="number">1</span>).pdf(plot_x)</span><br><span class="line"></span><br><span class="line">    log_dens = KernelDensity(bandwidth=<span class="number">1</span>).fit(x).score_samples(plot_x)</span><br><span class="line"></span><br><span class="line">    plt.figure(),</span><br><span class="line">    plt.fill(plot_x, true_dens, fc=<span class="string">'#AAAAFF'</span>, label=<span class="string">'true_density'</span>)</span><br><span class="line">    plt.plot(plot_x, np.exp(log_dens), <span class="string">'r'</span>, label=<span class="string">'estimated_density'</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(x.shape[<span class="number">0</span>]):</span><br><span class="line">        plt.plot(x[:, <span class="number">0</span>], np.zeros(x.shape[<span class="number">0</span>])<span class="number">-0.01</span>, <span class="string">'g*'</span>) </span><br><span class="line">    plt.legend()</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1.] <a href="http://scikit-learn.org/stable/auto_examples/neighbors/plot_kde_1d.html#sphx-glr-auto-examples-neighbors-plot-kde-1d-py" target="_blank" rel="noopener">sklearn:Simple 1D Kernel Density Estimation</a></p><p>[2.] Richard O. Duda, Peter E. Hart, and David G. Stork. 2000. Pattern Classification (2nd Edition). Wiley-Interscience, New York, NY, USA.</p><p>[3. ]<a href="https://en.wikipedia.org/wiki/Kernel_density_estimation" target="_blank" rel="noopener">Kernel density estimation</a></p><p>[4.] 边肇祺, 张学工, 2000. 模式识别. 清华大学出版社.</p>]]></content>
      
      
      
        <tags>
            
            <tag> pattern recognition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv 获取图像最大连通域 c++和python版</title>
      <link href="/2018/06/25/opencv-%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%9F%9F/"/>
      <url>/2018/06/25/opencv-%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在印象笔记中写过一个python+opencv版的最大连通域标记的程序，当时使用的是opencv2版本中的findContours函数作为载体，由于没有在意findContours中的各个contours之间的hierarchy关系，后来在一次实验中发现这种方式是有不足之处的，最方便的还是使用连通域标记算法将图像标记为各个连通域，然后在取连通域最大的区域这种方法。</p><h1 id="错误的版本"><a href="#错误的版本" class="headerlink" title="错误的版本"></a>错误的版本</h1><p>先贴出错误的版本，这个版本的想法是使用findContours函数找到各个连通域的contours，然后选取contours面积最大的那个作为目标区域，并将其填充。findContours使用的是EXTERNAL的方式标记边缘。显然这种方法如果是一个大的连通域里面是中空的，则标记后的最大连通域会将中间空的部分填充上，因此出错。</p><h2 id="Python版"><a href="#Python版" class="headerlink" title="Python版"></a>Python版</h2><p>之前的python版主要实现功能是利用opencv获取最大连通区域并去除。将之前在印象笔记里写的记录摘抄下来如下:</p><p>主要使用了如下方法：</p><blockquote><ul><li>首先通过findContours函数找到二值图像中的所有边界(这块看需要调节里面的参数)</li><li>然后通过contourArea函数计算每个边界内的面积</li><li>最后通过fillConvexPoly函数将面积最大的边界内部涂成背景</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">​</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    img = cv2.imread(<span class="string">'bw.bmp'</span>)</span><br><span class="line">    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">​</span><br><span class="line">    <span class="comment">#find contours of all the components and holes </span></span><br><span class="line">    gray_temp = gray.copy() <span class="comment">#copy the gray image because function</span></span><br><span class="line">                            <span class="comment">#findContours will change the imput image into another  </span></span><br><span class="line">    contours, hierarchy = cv2.findContours(gray_temp, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">​</span><br><span class="line">    <span class="comment">#show the contours of the imput image</span></span><br><span class="line">    cv2.drawContours(img, contours, <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    plt.figure(<span class="string">'original image with contours'</span>), plt.imshow(img, cmap = <span class="string">'gray'</span>)</span><br><span class="line">​</span><br><span class="line">    <span class="comment">#find the max area of all the contours and fill it with 0</span></span><br><span class="line">    area = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(contours)):</span><br><span class="line">        area.append(cv2.contourArea(contours[i]))</span><br><span class="line">    max_idx = np.argmax(area)</span><br><span class="line">    cv2.fillConvexPoly(gray, contours[max_idx], <span class="number">0</span>)</span><br><span class="line">    <span class="comment">#show image without max connect components </span></span><br><span class="line">    plt.figure(<span class="string">'remove max connect com'</span>), plt.imshow(gray, cmap = <span class="string">'gray'</span>)</span><br><span class="line">​</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>结果如下:</p><img src="/2018/06/25/opencv-%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%9F%9F/contours.png" class="" width="400" height="400" title="原始图像"><img src="/2018/06/25/opencv-%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%9F%9F/result.png" class="" width="400" height="400" title="去除结果"><p>分析上述结果可以发现存在两个问题:</p><ol><li>使用findContours函数检测边缘时如果最大连通域出现中空情况，则结果会将中空的部分填充上，得到错误的结果，本图因为中间没空，所以看起来效果是对的。</li><li>使用fillConvexPoly这个函数是有缺陷的，如果最大连通域不是凸的，则会得到错误的填充结果。</li></ol><h2 id="c-版"><a href="#c-版" class="headerlink" title="c++版"></a>c++版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void findLargesrArea(Mat srcImage, Mat &amp;dstImage)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;Point&gt;&gt;contours;</span><br><span class="line">    vector&lt;Vec4i&gt;hierarchy;</span><br><span class="line"></span><br><span class="line">    findContours(srcImage.clone(), contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_NONE);</span><br><span class="line"></span><br><span class="line">    double max_area = 0;</span><br><span class="line">    int index = 0;</span><br><span class="line">    for(int i = 0; i &lt; contours.size(); i++) </span><br><span class="line">    &#123;</span><br><span class="line">        if(contourArea(contours[i]) &gt; max_area)</span><br><span class="line">        &#123;</span><br><span class="line">            max_area = contourArea(contours[i]); </span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //cout &lt;&lt; &quot;max_index: &quot; &lt;&lt; index &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    dstImage =  Mat::zeros(srcImage.rows, srcImage.cols, srcImage.type()); </span><br><span class="line">    drawContours(dstImage, contours, index, Scalar(255));</span><br><span class="line">    imfill(dstImage, dstImage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void imfill(Mat srcimage, Mat &amp;dstimage)</span><br><span class="line">&#123;</span><br><span class="line">    Size m_Size = srcimage.size();  </span><br><span class="line">    Mat temimage = Mat::zeros(m_Size.height + 2, m_Size.width + 2, srcimage.type());</span><br><span class="line"></span><br><span class="line">    srcimage.copyTo(temimage(Range(1, m_Size.height + 1), Range(1, m_Size.width + 1)));  </span><br><span class="line">    floodFill(temimage, Point(0,0), Scalar(255)); </span><br><span class="line">    Mat cutImg;</span><br><span class="line">    temimage(Range(1, m_Size.height + 1), Range(1, m_Size.width + 1)).copyTo(cutImg);  </span><br><span class="line">    dstimage = srcimage | (~cutImg);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++这个版本存在上述第1个问题，但是不存在第2个问题，原因是其使用了自定义的imfill函数，避免了图像非凸出现错误的情况。</p><h1 id="改进的版本"><a href="#改进的版本" class="headerlink" title="改进的版本"></a>改进的版本</h1><h2 id="Python版-1"><a href="#Python版-1" class="headerlink" title="Python版"></a>Python版</h2><p>最近发现图像处理库skimage很好用，因此用skimage写了一个函数用于标记最大连通域:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestConnectComponent</span><span class="params">(bw_img, )</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    compute largest Connect component of an labeled image</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">    ---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    bw_img:</span></span><br><span class="line"><span class="string">        binary image</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">    ---</span></span><br><span class="line"><span class="string">        &gt;&gt;&gt; lcc = largestConnectComponent(bw_img)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    labeled_img, num = label(bw_img, neighbors=<span class="number">4</span>, background=<span class="number">0</span>, return_num=<span class="literal">True</span>)    </span><br><span class="line">    <span class="comment"># plt.figure(), plt.imshow(labeled_img, 'gray')</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># max_label = 0</span></span><br><span class="line">    max_label = <span class="number">1</span></span><br><span class="line">    max_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num+<span class="number">1</span>): <span class="comment"># 这里从1开始，防止将背景设置为最大连通域</span></span><br><span class="line">        <span class="keyword">if</span> np.sum(labeled_img == i) &gt; max_num:</span><br><span class="line">            max_num = np.sum(labeled_img == i)</span><br><span class="line">            max_label = i</span><br><span class="line">    lcc = (labeled_img == max_label)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lcc</span><br></pre></td></tr></table></figure><p><strong>注意(2018.10.10添加)</strong></p><p>有一次我在使用的时候发现有个参数还挺重要，就是这个<code>max_label</code>,如果把它设置为0，那么当一张图像只有一个连通域的时候，其结果正好是原始图像的反。</p><p>检查代码发现在这个地方:<code>lcc = (labeled_img == max_label)</code>.如果只有一个最大连通域，那么函数不会执行<code>for</code>循环，直接进入<code>lcc = (labeled_img == max_label)</code>,此时如果<code>max_label</code>如果是<code>0</code>，则会直接把背景当做最大连通域了，因此必须把<code>max_label</code>设置为1.</p><img src="/2018/06/25/opencv-%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%9F%9F/before.png" class="" title="原始二值图像"><img src="/2018/06/25/opencv-%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%9F%9F/0-after.png" class="" title="`max_label`为`0`时结果"><img src="/2018/06/25/opencv-%E8%8E%B7%E5%8F%96%E5%9B%BE%E5%83%8F%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%9F%9F/1-after.png" class="" title="`max_label`为`1`时结果"><h2 id="c-版-1"><a href="#c-版-1" class="headerlink" title="c++版"></a>c++版</h2><p>由于opencv3中增加了连通域标记函数，因此使得查找最大连通域变得更加容易。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">void DefectsDetector::LargestConnecttedComponent(Mat srcImage, Mat &amp;dstImage)</span><br><span class="line">&#123;</span><br><span class="line">    Mat temp;</span><br><span class="line">    Mat labels;</span><br><span class="line">    srcImage.copyTo(temp);</span><br><span class="line"></span><br><span class="line">    //1. 标记连通域</span><br><span class="line">    int n_comps = connectedComponents(temp, labels, 4, CV_16U);</span><br><span class="line">    vector&lt;int&gt; histogram_of_labels;</span><br><span class="line">    for (int i = 0; i &lt; n_comps; i++)//初始化labels的个数为0</span><br><span class="line">    &#123;</span><br><span class="line">        histogram_of_labels.push_back(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rows = labels.rows;</span><br><span class="line">    int cols = labels.cols;</span><br><span class="line">    for (int row = 0; row &lt; rows; row++) //计算每个labels的个数</span><br><span class="line">    &#123;</span><br><span class="line">        for (int col = 0; col &lt; cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            histogram_of_labels.at(labels.at&lt;unsigned short&gt;(row, col)) += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    histogram_of_labels.at(0) = 0; //将背景的labels个数设置为0</span><br><span class="line"></span><br><span class="line">    //2. 计算最大的连通域labels索引</span><br><span class="line">    int maximum = 0;</span><br><span class="line">    int max_idx = 0;</span><br><span class="line">    for (int i = 0; i &lt; n_comps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (histogram_of_labels.at(i) &gt; maximum)</span><br><span class="line">        &#123;</span><br><span class="line">            maximum = histogram_of_labels.at(i);</span><br><span class="line">            max_idx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3. 将最大连通域标记为1</span><br><span class="line">    for (int row = 0; row &lt; rows; row++) </span><br><span class="line">    &#123;</span><br><span class="line">        for (int col = 0; col &lt; cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (labels.at&lt;unsigned short&gt;(row, col) == max_idx)</span><br><span class="line">            &#123;</span><br><span class="line">                labels.at&lt;unsigned short&gt;(row, col) = 255;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                labels.at&lt;unsigned short&gt;(row, col) = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //4. 将图像更改为CV_8U格式</span><br><span class="line">    labels.convertTo(dstImage, CV_8U);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> image processing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> image processing </tag>
            
            <tag> c++ </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mfc遍历指定文件夹下的所有文件并排序</title>
      <link href="/2018/06/25/mfc%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/"/>
      <url>/2018/06/25/mfc%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>MFC下遍历文件夹下的所有文件，借助于<strong>CString</strong>类和<strong>CFileFind</strong>类的便捷，代码如下：</p><a id="more"></a><h1 id="只有一层文件结构"><a href="#只有一层文件结构" class="headerlink" title="只有一层文件结构"></a>只有一层文件结构</h1><p>很多时候我们要处理的文件只在一个特定的文件夹下，且该路径下除了待处理的文件之外没有其他文件夹，这时情况比较简单，不需要迭代处理，直接按照下面的操作即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CString filepath = _T(&quot;/path/to/folder/&quot;); </span><br><span class="line">CString filename = _T(&quot;&quot;);</span><br><span class="line">CString fullname = _T(&quot;&quot;);</span><br><span class="line"></span><br><span class="line">CFileFind find;</span><br><span class="line">BOOL IsFind = find.FindFile(filepath + _T(&quot;/*.*&quot;));</span><br><span class="line"></span><br><span class="line">while (IsFind)</span><br><span class="line">&#123;</span><br><span class="line">    IsFind = find.FindNextFile();</span><br><span class="line">    if (find.IsDots())</span><br><span class="line">    &#123;</span><br><span class="line">        continue;</span><br><span class="line">    ｝</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        filename = find.GetFileName();</span><br><span class="line">        fullname = filepath + filename;</span><br><span class="line">        cout &lt;&lt; fullname &lt;&lt; endl;</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h1 id="多层文件结构"><a href="#多层文件结构" class="headerlink" title="多层文件结构"></a>多层文件结构</h1><p>有时候我们处理的文件有多个文件结构，也就是说文件夹下面还有文件夹，这时候需要采用递归的方式遍历。<strong>举个例子</strong>，比如我们要处理一批后缀名为<strong><em>.bmp</em></strong>的文件,且这些文件在一个根目录下面的很多子目录下，那么我们可以这样处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void BroseAllFiles(CString filepath)</span><br><span class="line">&#123;</span><br><span class="line">    //检测路径是否正确并添加必要信息</span><br><span class="line">    if (filepath == _T(&quot;&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        if (filepath.Right(1) != _T(&quot;&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            filepath += _T(&quot;\\&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        filepath += _T(&quot;*.*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //递归枚举文件夹下的内容</span><br><span class="line">    CFileFind find;</span><br><span class="line">    CString strpath;</span><br><span class="line">    CString str_fileName;</span><br><span class="line">    CString fullname;</span><br><span class="line">    BOOL IsFind = find.FindFile(filepath);</span><br><span class="line"></span><br><span class="line">    while (IsFind)</span><br><span class="line">    &#123;</span><br><span class="line">        IsFind = find.FindNextFile();</span><br><span class="line">        strpath = find.GetFilePath();</span><br><span class="line"></span><br><span class="line">        if (find.IsDirectory() &amp;&amp; !find.IsDots())</span><br><span class="line">        &#123;</span><br><span class="line">            BroseAllFiles(strpath);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!find.IsDierctory() &amp;&amp; !find.IsDots())</span><br><span class="line">        &#123;</span><br><span class="line">            str_fileName = find.GetFileName();</span><br><span class="line">            if (str_fileName.Right(3) == _T(&quot;bmp&quot;)) //如果后缀是bmp文件才处理</span><br><span class="line">            &#123;</span><br><span class="line">                fullname = strpath + str_fileName;</span><br><span class="line">                cout &lt;&lt; fullname &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注：这个函数是对照参考资料写的，没有经过实际验证，如果出错请自行修改。</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>另一个问题是如果我们的文件是按照序号排列的，比如<code>1.bmp, 2.bmp, ..., 10.bmp, ... 100.bmp</code>， 当遍历完之后，发现结果会是这样：<code>1.bmp, 10.bmp, 100.bmp, 2.bmp ... 9.bmp</code>。因此我们需要给查找到的文件排个序。想法也很简单，如果你的文件名像上面给的例子一样命名，那我们只要把文件中<code>.bmp</code>之前的内容转化成数字再排个序就好了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SortbyNumASC</span><span class="params">(<span class="keyword">const</span> CString&amp; x, <span class="keyword">const</span> CString&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nLeft, nRight;</span><br><span class="line">    nLeft = atoi(x.Left(x.ReverseFind(<span class="string">'.'</span>)));</span><br><span class="line">    nRight = atoi(y.Left(y.ReverseFind(<span class="string">'.'</span>)));</span><br><span class="line">    <span class="keyword">return</span> nLeft &lt; nRight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入文件到fileList中</span></span><br><span class="line">CFileFind finder;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CString&gt; fileList;</span><br><span class="line"></span><br><span class="line">BOOL bHaveFiles = finder.FindFile(<span class="string">"*.*"</span>);</span><br><span class="line"><span class="keyword">while</span> (bHaveFiles)</span><br><span class="line">&#123;</span><br><span class="line">    bHaveFiles = finder.FindNextFile();</span><br><span class="line">    fileList.push_back(finder.GetFileName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由小到大排</span></span><br><span class="line">sort(fileList.begin(), fileList.end(), SortbyNumASC);</span><br></pre></td></tr></table></figure><p>在我的问题中，文件命名方式如下： <code>CS0001G_A_15.bmp</code>, 因此这里把第二个<code>_</code>后面的字符串中的数字转化为<code>int</code>型数据即可，因此这里对上述代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SortbynumASC</span><span class="params">(<span class="keyword">const</span> CString&amp; x, <span class="keyword">const</span> CString&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nLeft = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nRight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nLeft = atoi(x.Right(x.GetLength()<span class="number">-1</span> - x.ReverseFind(<span class="string">'_'</span>)));</span><br><span class="line">    nRight = atoi(y.Right(y.GetLength() - <span class="number">1</span> - y.ReverseFind(<span class="string">'_'</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nLeft &lt; nRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他部分参考上面代码</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1.] <a href="https://blog.csdn.net/flyfish1986/article/details/5372427" target="_blank" rel="noopener">https://blog.csdn.net/flyfish1986/article/details/5372427</a><br>[2.] <a href="https://blog.csdn.net/yal179/article/details/32123557" target="_blank" rel="noopener">https://blog.csdn.net/yal179/article/details/32123557</a></p>]]></content>
      
      
      <categories>
          
          <category> MFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python: ubuntu16.04 安装 vtk python版</title>
      <link href="/2018/03/14/python-ubuntu16-04-install-vtk-python/"/>
      <url>/2018/03/14/python-ubuntu16-04-install-vtk-python/</url>
      
        <content type="html"><![CDATA[<p>为了在图像三维分割之后显示出分割效果，因此安装VTK。</p><p>步骤很简单，如下：</p><a id="more"></a><h3 id="安装各种依赖包"><a href="#安装各种依赖包" class="headerlink" title="安装各种依赖包"></a>安装各种依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mesa-common-dev</span><br><span class="line">$ sudo apt-get install libgl1-mesa-dev</span><br><span class="line">$ sudo apt-get install cmake-curses-gui</span><br><span class="line">$ sudo apt-get install libxt-dev</span><br></pre></td></tr></table></figure><h3 id="VTK官网下载源码"><a href="#VTK官网下载源码" class="headerlink" title="VTK官网下载源码"></a>VTK官网下载源码</h3><p><a href="http://www.vtk.org/download/" target="_blank" rel="noopener">http://www.vtk.org/download/</a></p><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>解压下载的文件之后通过<code>terminal</code>进入源码文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/<span class="built_in">source</span></span><br><span class="line">$ mkdir VTK-build <span class="comment">#这个名称是可以随便起的，比如VTK-bin</span></span><br><span class="line">$ <span class="built_in">cd</span> VTK-build</span><br><span class="line">$ ccmake ../</span><br></pre></td></tr></table></figure><p>打开界面如下(里面是我配置的一些参数)：</p><img src="/2018/03/14/python-ubuntu16-04-install-vtk-python/config.png" class="" title="参数配置"><img src="/2018/03/14/python-ubuntu16-04-install-vtk-python/config2.png" class="" title="参数配置"><p>按照配置下面的说明：<code>c</code>表示确定， <code>q</code>表示退出， <code>g</code>表示生成，<code>enter</code>切换各种参数的状态，等等。<br>注意要使用<code>Python</code>的话就要把<code>VTK_WRAP_PYTHONON</code>设置为<code>ON</code>。<br>全部设置完成后按<code>c</code>确认，全部确认完成后按<code>g</code>生成，成功后会自动退出。<br>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="comment">#这一步需要很久，具体时间依电脑配置而异，一般在半小时以上</span></span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ipython </span><br><span class="line">$ import vtk</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> vtk </tag>
            
            <tag> ubuntu </tag>
            
            <tag> 3d reconstruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>machine learning: fuzzy c-means Python实现</title>
      <link href="/2018/03/07/machine-learning-python-implementation-of-fuzzy-c-means/"/>
      <url>/2018/03/07/machine-learning-python-implementation-of-fuzzy-c-means/</url>
      
        <content type="html"><![CDATA[<p>说明：FCM python 简单实现</p><p>在我看来，真正厉害的不是如何实现，而是怎么对这个问题求解，即我们利用的更新参数的公式是怎么来的。具体就得看原论文[4]了。</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division, print_function</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.colors = [<span class="string">'b'</span>, <span class="string">'orange'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'c'</span>, <span class="string">'m'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'Brown'</span>, <span class="string">'ForestGreen'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Define three cluster centers</span></span><br><span class="line">        centers = [[<span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">                [<span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">                [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Define three cluster sigmas in x and y, respectively</span></span><br><span class="line">        sigmas = [[<span class="number">0.8</span>, <span class="number">0.3</span>],</span><br><span class="line">                [<span class="number">0.3</span>, <span class="number">0.5</span>],</span><br><span class="line">                [<span class="number">1.1</span>, <span class="number">0.7</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Generate test data</span></span><br><span class="line">        np.random.seed(<span class="number">42</span>)  <span class="comment"># Set seed for reproducibility</span></span><br><span class="line">        self.xpts = np.zeros(<span class="number">1</span>)</span><br><span class="line">        self.ypts = np.zeros(<span class="number">1</span>)</span><br><span class="line">        self.labels = np.zeros(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 伪造3个高斯分布，以u和sigma作为特征分布</span></span><br><span class="line">        <span class="keyword">for</span> i, ((xmu, ymu), (xsigma, ysigma)) <span class="keyword">in</span> enumerate(zip(centers, sigmas)):</span><br><span class="line">            self.xpts = np.hstack((self.xpts, np.random.standard_normal(<span class="number">200</span>) * xsigma + xmu))</span><br><span class="line">            self.ypts = np.hstack((self.ypts, np.random.standard_normal(<span class="number">200</span>) * ysigma + ymu))</span><br><span class="line">            self.labels = np.hstack((self.labels, np.ones(<span class="number">200</span>) * i))</span><br><span class="line">        <span class="keyword">return</span> self.xpts, self.ypts, self.labels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visualize</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Visualize the test data</span></span><br><span class="line">        fig0, ax0 = plt.subplots()</span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            ax0.plot(self.xpts[self.labels == label], self.ypts[self.labels == label], <span class="string">'.'</span>,</span><br><span class="line">                    color=self.colors[label])</span><br><span class="line">        ax0.set_title(<span class="string">'Test data: 200 points x3 clusters.'</span>)</span><br><span class="line">        <span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fuzzy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, xpts, ypts, labels)</span>:</span></span><br><span class="line">        self.xpts = xpts</span><br><span class="line">        self.ypts = ypts</span><br><span class="line">        self.labels = labels</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_norm1</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        array = np.abs(array)</span><br><span class="line">        <span class="keyword">return</span> np.sum(array)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_normalize_rows</span><span class="params">(self, rows)</span>:</span></span><br><span class="line">        normalized_rows = rows / np.sum(rows, axis=<span class="number">1</span>, keepdims=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> normalized_rows</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cluster</span><span class="params">(self, classes, m = <span class="number">2</span>, niter = <span class="number">1000</span>, error = <span class="number">1e-5</span>)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># init u</span></span><br><span class="line">        <span class="comment"># u = np.ones([len(self.labels), classes], dtype=np.float32) / 3</span></span><br><span class="line">        n_data = self.xpts.shape[<span class="number">0</span>]</span><br><span class="line">        u = np.random.rand(n_data, classes)</span><br><span class="line">        u = self._normalize_rows(u)</span><br><span class="line"></span><br><span class="line">        self.x = np.array(zip(self.xpts, self.ypts))</span><br><span class="line">        </span><br><span class="line">        len_j = u.shape[<span class="number">1</span>]</span><br><span class="line">        c = np.zeros([len_j, <span class="number">2</span>], dtype=np.float32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> xrange(niter):</span><br><span class="line">            <span class="comment"># calculate c_j</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len_j):</span><br><span class="line">                u_j = u[:, j]</span><br><span class="line">                u_jm = u_j ** m</span><br><span class="line">                numer = np.dot(u_jm, self.x)</span><br><span class="line">                deno = np.sum(u_jm)</span><br><span class="line">                c[j] = numer / deno</span><br><span class="line"></span><br><span class="line">            <span class="comment"># update u_k</span></span><br><span class="line">            u_new = np.zeros_like(u)</span><br><span class="line">            data_size = self.x.shape[<span class="number">0</span>]</span><br><span class="line">            class_size = c.shape[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(data_size):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> xrange(class_size):</span><br><span class="line">                    numer = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(c.shape[<span class="number">0</span>]):</span><br><span class="line">                        temp = self._norm1(self.x[i] - c[j]) / self._norm1(self.x[i] - c[k])</span><br><span class="line">                        temp = temp ** (<span class="number">2</span> / (m<span class="number">-1</span>))</span><br><span class="line">                        numer += temp</span><br><span class="line">                    u_new[i, j] = <span class="number">1</span> / numer</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># check convergence</span></span><br><span class="line">            print(<span class="string">'FCM steps:'</span>, n)</span><br><span class="line">            <span class="keyword">if</span>(self._norm1(u - u_new) &lt; error):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># update u</span></span><br><span class="line">            u = u_new</span><br><span class="line"></span><br><span class="line">        <span class="comment"># return value and center </span></span><br><span class="line">        predict = np.argmax(u, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> c, predict</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># generate data </span></span><br><span class="line">    data = Data()</span><br><span class="line">    xpts, ypts, labels = data.generate()</span><br><span class="line">    data.visualize()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fuzzy c means</span></span><br><span class="line">    fuzzy = Fuzzy(xpts, ypts, labels)</span><br><span class="line">    center, predict_labels = fuzzy.cluster(classes=<span class="number">3</span>, m=<span class="number">2</span>, niter = <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># visualize</span></span><br><span class="line">    colors = [<span class="string">'b'</span>, <span class="string">'orange'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'c'</span>, <span class="string">'m'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'Brown'</span>, <span class="string">'ForestGreen'</span>]</span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">3</span>):</span><br><span class="line">        ax.plot(xpts[predict_labels == i],</span><br><span class="line">                ypts[predict_labels == i], </span><br><span class="line">                <span class="string">'.'</span>,</span><br><span class="line">                color=colors[i])</span><br><span class="line">    <span class="keyword">for</span> pt <span class="keyword">in</span> center:</span><br><span class="line">        ax.plot(pt[<span class="number">0</span>], pt[<span class="number">1</span>], <span class="string">'rs'</span>)</span><br><span class="line">    ax.set_title(<span class="string">'clustering results'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><img src="/2018/03/07/machine-learning-python-implementation-of-fuzzy-c-means/clustering.png" class="" title="结果"><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>主要实现一下fuzzy c means，理解其实现过程。<br>注意，fcm实现过程中degree of memerbership 矩阵$U$初始化需要满足三个条件[1].我在第一次初始化时直接给每个点属于每个类隶属度都设为相同的值，结果得到错误的结果。</p><p>后来参考了<a href="https://github.com/scikit-fuzzy/scikit-fuzzy" target="_blank" rel="noopener">skfuzzy</a>的初始化方式，即随机初始化，得到正确的结果。详情直接看源码。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://home.deib.polimi.it/matteucc/Clustering/tutorial_html/cmeans.html" target="_blank" rel="noopener">A Tutorial on Clustering Algorithms</a></li><li><a href="https://pythonhosted.org/scikit-fuzzy/auto_examples/plot_cmeans.html" target="_blank" rel="noopener">skfuzzy demo</a></li><li><a href="https://github.com/scikit-fuzzy/scikit-fuzzy" target="_blank" rel="noopener">skfuzzy</a></li><li>J. C. Dunn (1973): “A Fuzzy Relative of the ISODATA Process and Its Use in Detecting Compact Well-Separated Clusters”, Journal of Cybernetics 3: 32-57</li></ol>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pattern recognition </tag>
            
            <tag> python </tag>
            
            <tag> machine learning </tag>
            
            <tag> fuzzy c means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>comments: my altitude toward computer aided diagnosis</title>
      <link href="/2018/03/05/comments-my-altitude-toward-computer-aided-diagnosis/"/>
      <url>/2018/03/05/comments-my-altitude-toward-computer-aided-diagnosis/</url>
      
        <content type="html"><![CDATA[<p>I believe that right now, there are three (overlapping) areas in which CAD will have a major impact on pathology diagnostics, with increasing levels of impact and complexity[1].</p><ol><li><strong>CAD will increase efficiency of routine tasks.</strong> The first use cases for CAD in pathology will most likely address tedious routine diagnostic tasks that require great accuracy, such as finding metastases in lymph node sections. Most pathologists are not fond of this part of their work, yet it needs to be done well as it is of high relevance for tumor staging. A CAD algorithm that can detect metastases fully automatically will alleviate this task while actually increasing accuracy.</li><li><strong>CAD can improve accuracy of tasks in which some grading is involved.</strong> It is widely known that pathologists possess – at best – moderate reproducibility in such (semi-) quantitative tasks. A well-known example is Gleason scoring for prostate cancer. CAD may offer a powerful alternative, quantifying tissue changes that correspond with tumor grade in an accurate and reproducible manner.</li><li><strong>CAD may yield relevant information, for diagnosis and prognosis, which the human eye and mind are unable to recognize or appreciate.</strong> Instead of using a computer to mimic a pathologist in, for instance, grading a tumor, we could also try to obtain relevant quantitative data directly from WSI. These so-called “imaging biomarkers” may drastically change the way we extract information from tissue sections. While promising, it will take a significant amount of research and validation before the patient benefits from this type of application.</li></ol><p>It is my strong conviction that implementing CAD will tip the business case completely, and may even improve pathology diagnostics. Before we reach that point, a significant amount of work has to be carried out[1]. </p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol><li>[Computer-aided Diagnosis: The Tipping Point for Digital Pathology](Computer-aided Diagnosis: The Tipping Point for Digital Pathology)</li></ol>]]></content>
      
      
      <categories>
          
          <category> pattern recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cad </tag>
            
            <tag> image process </tag>
            
            <tag> pattern recognition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>summarize: CT 重建小结</title>
      <link href="/2018/03/02/summarize-CT-reconstruction/"/>
      <url>/2018/03/02/summarize-CT-reconstruction/</url>
      
        <content type="html"><![CDATA[<h2 id="CT基础概念"><a href="#CT基础概念" class="headerlink" title="CT基础概念"></a>CT基础概念</h2><hr><p>CT的基础概念以及CT重建的基本概念还是以看书为主吧，这里主要给出一些网址供参考：</p><a id="more"></a><p><a href="https://en.wikipedia.org/wiki/Tomographic_reconstruction" target="_blank" rel="noopener">wikipedia: Tomographic reconstruction</a><br><br><a href="http://xrayphysics.com/ctsim.html" target="_blank" rel="noopener">CT Physics: CT Reconstruction and Helical CT</a><br><br><a href="http://xrayphysics.com/index.html" target="_blank" rel="noopener">XRayPhysics - Interactive Radiology Physics</a></p><h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><hr><p>采集图像的探测器为一个面阵，投影图像矩阵大小为2048*2048，像素边长0.0013mm，共分540个视角在[0-180)内均匀采样.采集的图像如下所示：</p><img src="/2018/03/02/summarize-CT-reconstruction/sinogram.png" class="" title="原始投影数据"><p>对于上面的数据，我们只取其中一个断层，即中间一层(这里我手工选择了每个文件的第780行，然后按顺序将数据罗列起来)，取出的数据如图所示：</p><img src="/2018/03/02/summarize-CT-reconstruction/original_sinogram.png" class="" title="中间断层投影数据"><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><hr><p>这里讲的预处理主要是针对<strong>投影数据</strong>做的一系列操作。常见的预处理操作包括暗电流与白场归一化(Dark current and white field normalization)、对齐投影中心(Centering the sinogram)、去除环状伪影(Ring artifact reduction)等操作。<a href="https://www.mcs.anl.gov/research/projects/X-ray-cmt/rivers/tutorial.html" target="_blank" rel="noopener">这篇文章</a>详细介绍了CT图像重建过程中常见的预处理过程。<br><br>这里主要根据现有数据和<a href="https://www.mcs.anl.gov/research/projects/X-ray-cmt/rivers/tutorial.html" target="_blank" rel="noopener">参考文献</a>中的部分过程对预处理进行说明。</p><h3 id="对齐投影中心"><a href="#对齐投影中心" class="headerlink" title="对齐投影中心"></a>对齐投影中心</h3><p>没有对齐投影中心的投影数据会得到错误的重建结果。<br><br>工具箱<a href="https://tomopy.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">tomopy</a>提供了几种不同的自动查找对称中心方法。如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find center </span></span><br><span class="line">center = tomopy.find_center(proj, theta, ind=<span class="number">0</span>, init=<span class="number">1046</span>, tol=<span class="number">0.1</span>)</span><br><span class="line">print(center)</span><br></pre></td></tr></table></figure><p>详情参考<a href="https://tomopy.readthedocs.io/en/latest/api/tomopy.recon.rotation.html" target="_blank" rel="noopener">tomopy 文档</a>.</p><p><em>N.B. : <a href="http://www.astra-toolbox.com/" target="_blank" rel="noopener">astra toolbox</a>中没有提供自动查找对称中心的方法，因此在<code>astra toolbox</code>中最简单实用的方法就是直接把投影数据剪切成<strong>以对称中心为中心</strong>的新数据。如下：</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># load sinogram</span></span><br><span class="line">sinogram = Image.open(<span class="string">'sino_median.tiff'</span>)</span><br><span class="line">sinogram = np.array(sinogram, dtype=np.float)</span><br><span class="line">sinogram = sinogram[:, <span class="number">1048</span><span class="number">-1000</span>:<span class="number">1048</span>+<span class="number">1001</span>]</span><br><span class="line">plt.figure(), plt.imshow(sinogram, cmap=<span class="string">'gray'</span>)</span><br><span class="line"><span class="comment"># 这样剪切一下就把原始数据剪切为以1048为中心的投影数据了。</span></span><br><span class="line"><span class="comment"># 注： 在tomopy中数据中心允许是float型数据，而astra toolbox中只支持int型中心。</span></span><br></pre></td></tr></table></figure><p>下图分别是使用未对齐中心和对齐中心的重建结果，重建算法使用<code>FBP</code>。</p><table><thead><tr><th align="center">未对齐中心</th><th align="center">对齐中心</th></tr></thead><tbody><tr><td align="center"><img src="/2018/03/02/summarize-CT-reconstruction/not_align.png" class="" width="300" height="300"></td><td align="center"><img src="/2018/03/02/summarize-CT-reconstruction/align.png" class="" width="300" height="300"></td></tr></tbody></table><h3 id="去除随机噪声"><a href="#去除随机噪声" class="headerlink" title="去除随机噪声"></a>去除随机噪声</h3><p>这里的随机噪声也即椒盐噪声，在投影域上表现为黑色和白色的随机圆点，圆点半径大小不一。目前因为只处理了一个截面，因此在其中一个截面上的噪声看起来是横向的条纹状，其表现如下：</p><table><thead><tr><th align="center">放大的投影图像</th><th align="center">投影图像截面图</th></tr></thead><tbody><tr><td align="center"><img src="/2018/03/02/summarize-CT-reconstruction/sinogram_random_noise.png" class="" width="300" height="300"></td><td align="center"><img src="/2018/03/02/summarize-CT-reconstruction/sinogram_random_noise_slice.png" class="" width="300" height="300"></td></tr></tbody></table><p>最简单也是比较通用的办法就是直接对投影图像进行<strong>中值滤波</strong>，中值滤波在保持图像边缘的情况下可以很好地滤除掉椒盐噪声。我们在处理其中一个断面的数据时由于噪声在水平方向呈现一个三角脉冲，因此利用这个特点首先将噪声检测出来，然后再滤除掉，操作过程如下：</p><ol><li>计算投影数据水平方向的差分，再取绝对值。</li><li>计算第1步得到图像的局部极小值，得到二值图像。二值图像前景为检测到的噪声，背景为正常区域。</li><li>根据两个相邻前景的距离信息修正二值图像。由于差分后的图像在脉冲噪声峰谷位置变化不大，因此在第2步可能会被识别为正常区域。这里将距离小于阈值t的两个前景合并为一个，本文中t取值为3。</li><li>利用<strong>非局部均值算法（non-local means）</strong>将检测到的噪声区域填充为新的值。</li></ol><p>去噪效果如下：</p><img src="/2018/03/02/summarize-CT-reconstruction/remove_random.png" class="" title="去除随机噪声之后的投影图像"><h3 id="去除环状伪影"><a href="#去除环状伪影" class="headerlink" title="去除环状伪影"></a>去除环状伪影</h3><p>环状伪影是重建过程中不可避免的一类噪声。其主要原因如下<a href="https://www.mcs.anl.gov/research/projects/X-ray-cmt/rivers/tutorial.html" target="_blank" rel="noopener">[1]</a>：</p><blockquote><ol><li>Drifts in the detector element sensitivity in between white-field calibrations</li><li>Non-linear detector element response</li><li>Higher energy harmonics in the incident beam</li></ol></blockquote><p>去除环状伪影的方法同样很多，基本上可以分为<em>从投影数据</em>去除和<em>从重建图像</em>去除两种，或者把两种方法进行组合。<br><br>一种最基本的去噪方法如下：<br></p><blockquote><ol><li>Compute the average row of the sinogram by summing down each column and dividing by the number of rows.  This average row should have very little high-frequency content, since real objects will be moving in the sinogram, and will be blurred out when computing the average row.  Anomalous detector elements will show up as spikes or dips in the average row.</li><li>Compute the magnitude of these detector anomalies by subtracting a smoothed version of the average row from the average row.</li><li>Subtract the result of step 2), the detector anomalies, from each row in the sinogram. This results in a sinogram with much less vertical striping.</li></ol></blockquote><p>去除环状伪影前后的重建图像大概长这个样子：</p><img src="/2018/03/02/summarize-CT-reconstruction/remove_ring_artifacts.png" class="" title="去除环状伪影前后的重建图像"><p>红色箭头表示去除之前的环状伪影，图右表示去除之后的效果。</p><h2 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h2><hr><p>重建可以按照不同的准则去区分，因此也就可以得到不同种类的方法。这里我们主要关心两种重建方法：基于解析的重建方法(以滤波反投影算法(Filter Back Projection, FBP)为代表)，基于迭代的方法。前者将系统看成是连续的过程，可以通过公式严格地推算出连续空间中每一个点的值，后者将系统构建成离散的网格，因此会得到离散的结果。前者可以通过推算的方法可以得到唯一的解，后者往往在求解一个变态的方程组，因此必须借助优化的方法尽量求出目标函数的全局最优解。<br><br>两者的一些区别现总结如下[30]，供读者参考。建议读者先了解两种方法的过程，然后再返回来看这几条对比。</p><ol><li><strong>【系统结构】</strong> 基于解析的重建方法在数据获取方面存在诸多限制，比如在采样过程中必须是<em>circular parallel beam</em>或者是<em>fan beam</em>这样的系统设置等等。而对于迭代方法来说，线性系统$ g = Xf $ 的每一行都对应着一束$x$射线的线积分，因此这种方式可以使射线的排布更加灵活.</li><li><strong>【数据处理】</strong> 由于最终得到的投影数据是一些在有限角度范围内的离散化数据,在使用基于解析的方法重建图像时,往往需要插值操作。而基于迭代的方法其系统方程可以直接描述离散线积分的过程,因此可以避免数据插值的过程。</li><li><strong>【约束条件】</strong> 基于迭代的方法可以通过增加约束条件的方式自由增加一些先验知识，但是基于解析的方法是不方便这么做的。</li><li><strong>【噪声抑制】</strong> 最重要的一个不足在于基于迭代的方法对低频的数据不连续性(data inconsistency)十分敏感，并且这种数据不连续性是在系统中普遍存在的。然而基于解析的方法对这种噪声是不敏感的，例如FBP算法，其在重建之前首先对数据做了滤波处理，因此这种低频噪声可以被滤掉。</li><li><strong>【计算速度】</strong> 另一个难点在于基于迭代的方法在重建过程中始终需要$f$是整张图像，因为需要$Xf$更新数据并和真是的投影数据$g$进行比较。这就意味着在迭代方法重建图像时，不仅被重建的物体需要在视野里，而且在视野里的一些其他东西比如患者躺的床也要被重建。而解析的方法则不会出现这种问题，因为在图像和空间中的任意一点可以被表达出来。这样解析方法就可以基于ROI进行重建，而不需要的东西可以不加考虑。(<em>注：迭代方法的ROI重建2014年之后也有人研究，现在是否已经成熟需要读者自己查资料了解</em>)</li></ol><h3 id="基于解析"><a href="#基于解析" class="headerlink" title="基于解析"></a>基于解析</h3><p>滤波反投影算法是解析方法中的一个重要代表。其主要的理论依据是<a href="https://en.wikipedia.org/wiki/Radon_transform" target="_blank" rel="noopener">Randon Transorm</a>。具体的理论过程请查看相应参考书，这里主要通过图像形象地描述一下滤波反投影的过程。</p><img src="/2018/03/02/summarize-CT-reconstruction/forward.png" class="" title="正过程"><p>上图显示了平行束投影正投影的过程，中间黑色方块表示被扫描物体，内部的白色圆圈表示其衰减系数和其他地方不同。分别采集了三个不同角度的投影数据：垂直方向(view1)，45度方向(view2)，水平方向(view3)。三个角度上的曲线表示射线穿过物体之后剩余的强度曲线。<br><br>从射线前度曲线我们可以推断出，白色物体的衰减系数比黑色背景部分要低，因此在通过白色物体的区域剩余射线强度要高，在投影强度曲线上表现为一个脉冲。注意到这个脉冲在不同角度的投影强度曲线上位置是不同的。这让我想起来中学时代学过的三视图，通过一个视角看物体往往得不到其真实的形状，因此几何中使用三视图(主视图，俯视图，侧视图)来表现一个三维物体。这里的CT重建技术也和三视图有相似之处，只不过我们需要更多角度的投影数据来得到可以应用的重建结果。</p><img src="/2018/03/02/summarize-CT-reconstruction/3_views.png" class="" title="反投影"><p>最直观且简单的方法就如上图的<em>反投影</em>过程一样，将正投影得到的数据直接按照原来的方向反投回去。如将上一节中三个角度的投影数据直接反投影，得到上图<code>a</code>中的结果。三个角度反投影回去就会出现如图中的三条亮线，而且其中间圆点部分也和原始的图像相差很多。<code>b</code>中的反投影结果相比<code>a</code>中的结果更接近原始图像，这是因为使用了更多的投影数据，但是依然和原始图像有很大区别，尤其是物体内边缘的部分，看起来像光晕一样。</p><img src="/2018/03/02/summarize-CT-reconstruction/fbp_figure.png" class="" title="滤波反投影"><p>滤波反投影技术在一定程度上解决了上述直接反投影的问题，这里还涉及到另一个重要的定理:<a href="https://en.wikipedia.org/wiki/Projection-slice_theorem" target="_blank" rel="noopener">Fourier Slice Theorem</a>。其基本思想是先将投影数据进行滤波，然后再进行反投影。上图(<code>滤波反投影</code>)表示出了这个过程，首先把每个角度的投影数据都滤波处理，然后再反投影回去，得到重建图像。可以看出，当投影角度<strong>足够多</strong>时候，滤波反投影算法基本上可以重建出可以接受的结果。</p><h3 id="基于迭代"><a href="#基于迭代" class="headerlink" title="基于迭代"></a>基于迭代</h3><p>迭代的重建方法也可以继续往下按细了分，但是我知道的有限，因此也就直接介绍一下做过的一些东西。</p><img src="/2018/03/02/summarize-CT-reconstruction/module.png" class=""><p>上图是平行束投影的一个示意图，在迭代的方法中，我们把图中的过程描述为一个离散的线性模型：$g = X f$。其中：</p><ul><li><p>$g$是投影得到的数据，比如一个线性的探测器共有512个探测元，那么一个投影角度就得到<code>1*512</code>维的投影数据，转动物体(或者以某一个轴为中心转动源和探测器)，我们可以得到第二个投影角度的数据，并和第一个角度的数据合并，得到<code>2*512</code>维的数据… 不断更改投影角度，如在[0-180°)之间获取了360个角度，就会得到<code>360*512</code>维的数据，这里$g$是一个列向量，因此我们将$g$表示为<code>(360*512)×1</code>维的向量。</p></li><li><p>$X$是系统矩阵，一旦系统的给个参数确定了，如源到旋转轴的距离，旋转轴到探测器的距离，探测器的个数，数据采集的角度范围，需要采集多少个角度等等，系统矩阵<code>X</code>就会唯一确定。</p></li><li><p>$f$是待重建的图像，也是一个1维的列向量。假设我们要重建一个分辨率为<code>512*512</code>的图像，那么$f$的维度就为<code>1×(512*512)</code>，表示$f$是个列向量。</p></li></ul><p>通过上面的描述我们就把整个投影的<strong>正过程</strong>描述清楚了。接下来我们需要根据正过程建立一个目标函数，通过最小化这个目标函数来求解出待重建图像。</p><p>最简单的目标函数就是最小二乘项了，如下：</p><p>$$\underset{f}{min}:\frac{1}2{}||Xf - g||^2$$</p><p>然后就可以使用优化算法求解这个目标函数，得到的$f$就是我们重建出来的图像。</p><p>我们对上面的流程做一个总结，可以得到下面这三个步骤：</p><ol><li>找到一个合适的模型来描述这个系统</li><li>通过建立的模型来设计一个目标函数，使得待重建的图像是可以通过求解目标函数而得到，也就是说待重建的图像得在我们设计的这个目标函数解空间之内。</li><li>找到一个合适的优化算法，求解目标函数进而得到重建图像。</li></ol><p>前文提到过，迭代算法的实现过程是很灵活的，在于我们可以根据自己的需求增加约束项，来缩小解空间的范围，从而得到我们更关注的信息。比如我再列两个目标函数：<br>$$\underset{u}{min}{ \sum_{i}[Au-g+g\ln g-g\ln(pos(Au))]_i+\delta_P (Au)+\lambda \lVert (|\nabla u|) \rVert}<br>$$</p><p>$$\underset{u}{min}{ \lVert Au-g\rVert_1 + \lambda \lVert(|\nabla u|)\rVert}$$</p><p>如何让这些目标函数能够收敛而且最快速的收敛是优化算法要解决的问题。下图是我使用最小二乘项得到的仿真结果。</p><img src="/2018/03/02/summarize-CT-reconstruction/ls_result.png" class="" title="迭代法最小二乘项仿真结果"><p><strong>小剂量图像重建(low dose reconstruction)</strong></p><p>在基于解析的重建一节最后，我说道 <em>当投影角度足够多的时候，滤波反投影算法基本上可以重建出可以接受的结果</em> 。那么多少角度算是足够多呢？从图像的质量(常用的两个图像质量标准有空间分辨率和对比度分辨率)考虑当然是投影角度越多越好；但是从患者接受辐射量的角度来讲，我们希望在可接受的图像空间分辨率以及对比度分辨率下，需要的投影数据越少越好。学过<strong>信号与系统</strong>我们知道，要想无失真的从频域恢复原始信号，其采样率必须满足<a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem" target="_blank" rel="noopener">奈奎斯特采样定理</a>, 因此我们需要在投影角度的数量上做一个权衡。</p><p>在2006年，信号处理界发生了一件大事儿，<a href="https://en.wikipedia.org/wiki/Compressed_sensing" target="_blank" rel="noopener">压缩感知理论</a>号称可以超越<a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem" target="_blank" rel="noopener">奈奎斯特采样定理</a>，以低于信号频率2倍的采样率采样，然后无失真地恢复信号。实际上压缩感知理论是需要满足一定条件[35]的，但是恰好CT重建的过程满足可以使用压缩感知理论的条件，这正是减少图像投影角度的好时机。</p><p>前文我们在对比迭代和解析区别时提到，<em>基于迭代的方法可以在求解过程中灵活地增加一些约束条件</em> ，这一特点在解析方法中是不具备的，这也是基于迭代方法越来越被重视的原因之一。结合压缩感知理论和迭代方法的灵活性，近几年的论文中有相当大一部分都在讨论<code>low dose reconstruction</code>的问题，这里的<code>low dose</code>其中一方面指的就是减少投影角度。读者可以了解下面的一个公开比赛:<a href="https://www.aapm.org/GrandChallenge/LowDoseCT/" target="_blank" rel="noopener">Low Dose CT Grand Challenge</a>。下面是我使用<code>FBP</code>算法和<code>CP</code>算法[36]在 * <strong>20</strong>个投影角度下重建出来的图像对比*：</p><table><thead><tr><th align="center">原始图像</th><th align="center">FBP算法(解析法)</th><th align="center">CP算法(迭代法)</th></tr></thead><tbody><tr><td align="center"><img src="/2018/03/02/summarize-CT-reconstruction/origional_img.png" class=""></td><td align="center"><img src="/2018/03/02/summarize-CT-reconstruction/fbp_20_views.png" class=""></td><td align="center"><img src="/2018/03/02/summarize-CT-reconstruction/cp_20_views.png" class=""></td></tr></tbody></table><p><strong>基于ROI的图像重建</strong></p><p>同样是在前文对比中，我们提到了迭代方法的一个问题，<strong>计算量过大</strong>。我们可以举个例子：假设我们的线性系统是$g=Xf$。其中$g$是投影数据，$X$是系统矩阵，$f$是待重建物体。以我们手里有的真实数据为例，一行有2048个探测器，在(0-180°]之间采集540个角度，这样$g$的维度是<code>(540*2048)×1</code>,假设我们重建的图像$f$分辨率为<code>(512*512)×1</code>,那么系统矩阵$X$的维度为<code>(540*2048)×(512*512)</code>。每次正过程计算一遍$Xf$, 反过程计算一遍$x^Tg$, 如此迭代几千次甚至上万次，其计算量是相当大的。</p><p>迭代方法的起源也是很早的，但是就因为计算速度的原因使其发展的速度慢了下来，直到近些年计算机硬件的发展，特别是GPU运算已经越来越广泛，才使得迭代方法重新被重视起来。</p><p>提高计算速度的一个方法是提升硬件，还有可以像之前总结的一样，只关心ROI区域内部的重建(这种方法我不太清楚其原理，因此不能完全确定是否会提高速度。但是根据作者的描述应该是可以的)。从这个角度考虑我们之前的想法，即只重建感兴趣区域的边缘，也算是基于ROI重建范围之内的，只不过我们要重建的信息更少。这样一来是很有可能在不拼硬件的基础上提升计算速度的。</p><h2 id="工具箱"><a href="#工具箱" class="headerlink" title="工具箱"></a>工具箱</h2><hr><p>这里主要介绍两个工具包，<a href="http://www.astra-toolbox.com/" target="_blank" rel="noopener">astra toolbox</a>和<a href="https://tomopy.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">tomopy</a>。两个工具包都是开源的，具体的安装和使用方法就不过多介绍了，可以直接参考两个工具包的文档，这里主要是给大家提供一个链接，供大家选择。</p><h3 id="astra-toolbox"><a href="#astra-toolbox" class="headerlink" title="astra toolbox"></a>astra toolbox</h3><p><a href="http://www.astra-toolbox.com/" target="_blank" rel="noopener">astra toolbox</a>是我接触的第一个开源的重建工具包，我个人总结其特点如下：</p><ol><li>强大的GPU支持，<code>astra toolbox</code>给无论是传统的fbp算法还是基于迭代的优化算法都提供了GPU运算支持。降低了重建的运行时间。</li><li>同时这个工具包给提供了不少经典的以及流行的重建算法，方便用户验证除了重建算法之外的东西，包括CPU支持和GPU支持。</li><li>极大的灵活性。这里的灵活性是最重要的，因为这样可以让我们灵活地建立自己想要的系统结构，灵活地选择是否使用已存在的重建算法还是自定义算法等等。</li></ol><p>还可以参考下这两篇文章：</p><p><a href="https://www.osapublishing.org/oe/abstract.cfm?uri=oe-24-22-25129#articleFigures" target="_blank" rel="noopener">Fast and flexible X-ray tomography using the ASTRA toolbox</a></p><p><a href="https://www.sciencedirect.com/science/article/pii/S0304399115001060?via%3Dihub" target="_blank" rel="noopener">The ASTRA Toolbox: A platform for advanced algorithm development in electron tomography</a></p><h3 id="tomopy"><a href="#tomopy" class="headerlink" title="tomopy"></a>tomopy</h3><p><a href="https://tomopy.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">tomopy</a>可以作为<a href="http://www.astra-toolbox.com/" target="_blank" rel="noopener">astra toolbox</a>的一个补充，这个工具包的特点是更注重预处理和后处理的一些过程，其数据结构和astra toolbox不太一样。</p><p>一个比较有意思的地方在于tomopy将astra toobox扩展到tomopy下，这样用户可以直接通过tomopy调用astra toolbox中的重建算法，包括GPU支持的重建算法。点击<a href="https://tomopy.readthedocs.io/en/latest/ipynb/astra.html" target="_blank" rel="noopener"><strong>详情</strong></a>查看。</p><p><em>N.B. : 到我写这篇文章为止<code>tomopy</code>在<code>conda</code>库中还没有编译好的<code>windows</code>版本，其源码编译过程也是针对<code>linux</code>系统编写的，因此<code>windows</code>下使用起来需要费些周折。</em><br><br><em>同时tomopy文档中出现的一些功能还有部分没有实现，使用时需要注意</em></p><h2 id="可参考文献"><a href="#可参考文献" class="headerlink" title="可参考文献"></a>可参考文献</h2><p><em>N.B.黑体标出的是我建议阅读的文章。</em></p><ol><li>Chen, R.C., et al., PITRE: software for phase-sensitive X-ray image processing and tomography reconstruction. J Synchrotron Radiat, 2012. 19(Pt 5): p. 836-45.</li><li>张永栋, et al., 包覆燃料颗粒尺寸及其标准偏差对失效概率的影响. Influence of particle size and its standard deviation on failure probability of coated fuel particles, (12): p. 120603-1-120603-6.</li><li>李俊江, et al., CT图像环状伪影校正方法. Ring artifact correction for industrial CT images, (11): p. 1378-1382.</li><li>Yeol, L.S. and C.M. Hye, A Ring Artifact Correction Method: Validation by Micro-CT Imaging with Flat-Panel Detectors and a 2D Photon-Counting Detector. (2).</li><li>Yang, M., et al., Denoising method of X-ray phase contrast DR image for TRISO-coated fuel particles. Particuology, 2013. 11(6): p. 695-702.</li><li>Yang, M., et al., Imaging and measuring methods for coating layer thickness of TRISO-coated fuel particles with high accuracy. Ndt &amp; E International, 2013. 55: p. 82-89.</li><li>Kim, Y., J. Baek, and D. Hwang, Ring artifact correction using detector line-ratios in computed tomography. Optics Express, 2014. 22(11): p. 13380-13392.</li><li>Kim, W.K., et al., Nondestructive measurement of the coating thickness for simulated TRISO-coated fuel particles by using phase contrast X-ray radiography. Nuclear Engineering &amp; Design, 2008. 238(12): p. 3285-3291.</li><li>van Aarle, W., et al., Memory access optimization for iterative tomography on many-core architectures. 2013.</li><li>Tuy, H., An Inversion Formula for Cone-Beam Reconstruction. SIAM Journal on Applied Mathematics, 1983. 43: p. 546-552.</li><li>Smith, B.D., Image Reconstruction from Cone-Beam Projections: Necessary and Sufficient Conditions and Reconstruction Methods. IEEE Transactions on Medical Imaging, 1985. 4: p. 14-25.</li><li>Sidky, E.Y. and X. Pan, Image reconstruction in circular cone-beam computed tomography by constrained, total-variation minimization. Physics in Medicine &amp; Biology, 2008. 53: p. 4777.</li><li>Sánchez, A.A., Estimation of noise properties for TV-regularized image reconstruction in computed tomography. Physics in Medicine &amp; Biology, 2015. 60: p. 7007.</li><li>Gu, J. and J.C. Ye, Multi-Scale Wavelet Domain Residual Learning for Limited-Angle CT Reconstruction. arXiv:1703.01382 [cs], 2017.</li><li>Barrett, H.H., et al., Model observers for assessment of image quality. Proceedings of the National Academy of Sciences of the United States of America, 1993. 90: p. 9758-9765.</li><li>陈, 建., et al., CT重建中投影矩阵模型研究综述. CT理论与应用研究, 2014: p. 317-328.</li><li>Xia, D., et al., Optimization-based image reconstruction with artifact reduction in C-arm CBCT. Physics in Medicine &amp; Biology, 2016. 61: p. 7300.</li><li>Szczykutowicz, T.P., J. Hsieh, and G.-H. Chen. The dependence of image quality on the number of high and low kVp projections in dual energy CT using the prior image constrained compressed sensing (PICCS) algorithm. in Medical Imaging 2010: Physics of Medical Imaging. 2010.</li><li><strong>Sidky, E.Y., et al., Analysis of iterative region-of-interest image reconstruction for x-ray computed tomography. Journal of Medical Imaging, 2014. 1: p. 031007-031007.</strong></li><li>Sánchez, A.A., E.Y. Sidky, and X. Pan, Use of the Hotelling observer to optimize image reconstruction in digital breast tomosynthesis. Journal of Medical Imaging, 2015. 3: p. 011008-011008.</li><li>Han, X., et al., Algorithm-enabled exploration of image-quality potential of cone-beam CT in image-guided radiation therapy. Physics in Medicine and Biology, 2015. 60: p. 4601-4633.</li><li>Han, X., et al., Optimization-based reconstruction of sparse images from few-view projections. Physics in Medicine &amp; Biology, 2012. 57: p. 5245.</li><li>Han, X., et al., Algorithm-Enabled Low-Dose Micro-CT Imaging. IEEE Transactions on Medical Imaging, 2011. 30: p. 606-620.</li><li><strong>Guo, W. and W. Yin, Edge Guided Reconstruction for Compressive Imaging. SIAM Journal on Imaging Sciences, 2012. 5: p. 809-834.</strong></li><li>Bian, J., et al., Investigation of iterative image reconstruction in low-dose breast CT. Physics in Medicine &amp; Biology, 2014. 59: p. 2659.</li><li>Bian, J., et al., Optimization-based image reconstruction from sparse-view data in offset-detector CBCT. Physics in Medicine &amp; Biology, 2013. 58: p. 205.</li><li>Bian, J., et al., Evaluation of sparse-view reconstruction from flat-panel-detector cone-beam CT. Physics in Medicine &amp; Biology, 2010. 55: p. 6575.</li><li>Barber, R.F., et al., An algorithm for constrained one-step inversion of spectral CT data. Physics in Medicine &amp; Biology, 2016. 61: p. 3784.</li><li>Zhang, Z., et al., Artifact reduction in short-scan CBCT by use of optimization-based reconstruction. Physics in Medicine &amp; Biology, 2016. 61: p. 3387.</li><li>Sidky, E.Y., et al. Enhancing tissue structures with iterative image reconstruction for digital breast tomosynthesis. in Medical Imaging 2014: Physics of Medical Imaging. 2014. International Society for Optics and Photonics.</li><li>Sidky, E.Y., et al., Constrained TpV Minimization for Enhanced Exploitation of Gradient Sparsity: Application to CT Image Reconstruction. IEEE Journal of Translational Engineering in Health and Medicine, 2014. 2: p. 1-18.</li><li>Sanchez, A.A., E.Y. Sidky, and X. Pan, Region of interest based Hotelling observer for computed tomography with comparison to alternative methods. Journal of Medical Imaging, 2014. 1: p. 031010-031010.</li><li>Qi, Z., et al. A novel method to reduce data acquisition time in differential phase contrast: computed tomography using compressed sensing. 2009.</li><li>Choi, J., et al. Compressed sensing metal artifact removal in dental CT. in 2009 IEEE International Symposium on Biomedical Imaging: From Nano to Macro. 2009.</li><li><strong>Candes, E.J., J. Romberg, and T. Tao, Robust uncertainty principles: exact signal reconstruction from highly incomplete frequency information. IEEE Transactions on Information Theory, 2006. 52: p. 489-509.</strong></li><li><strong>Sidky, E.Y., J.H. Jørgensen, and X. Pan, Convex optimization problem prototyping for image reconstruction in computed tomography with the Chambolle–Pock algorithm. Physics in Medicine &amp; Biology, 2012. 57: p. 3065.</strong></li><li>Boin, M. and A. Haibel, Compensation of ring artefacts in synchrotron tomographic images. Optics Express, 2006. 14(25): p. 12071-12075.</li><li><strong>Geyer, L.L., et al., State of the Art: Iterative CT Reconstruction Techniques. Radiology, 2015. 276(2): p. 338-356.</strong></li><li>Huo, Q.R., et al., Removing Ring Artifacts in CBCT Images Using Smoothing Based on Relative Total Variation, in Neural Information Processing, Iconip 2016, Pt I, A. Hirose, et al., Editors. 2016, Springer Int Publishing Ag: Cham. p. 501-509.</li><li>Miqueles, E.X., et al., Generalized Titarenko’s algorithm for ring artefacts reduction. Journal of Synchrotron Radiation, 2014. 21: p. 1333-1346.</li><li>Munch, B., et al., Stripe and ring artifact removal with combined wavelet - Fourier filtering. Optics Express, 2009. 17(10): p. 8567-8591.</li><li>Kim, Y., D. Oh, and D. Hwang, Small-scale noise-like moire pattern caused by detector sensitivity inhomogeneity in computed tomography. Optics Express, 2017. 25(22): p. 27127-27145.</li><li>Cai, A.L., et al., Image reconstruction for cone-beam computed tomography using total p-variation plus Kullback-Leibler data divergence. Chinese Physics B, 2017. 26(7): p. 13.</li><li><strong>Zhao, W., et al., Using edge-preserving algorithm with non-local mean for significantly improved image-domain material decomposition in dual-energy CT. Physics in Medicine and Biology, 2016. 61(3): p. 1332-1351.</strong></li><li>Persson, M. and F. Gronberg, Bias-variance tradeoff in anticorrelated noise reduction for spectral CT. Medical Physics, 2017. 44(9): p. E242-E254.</li><li>Ulinuha, M.A., et al., Outer contour extraction of skull from CT scan images, in International Conference on Information Technology and Digital Applications, T. Hidayat and A. Sujarwo, Editors. 2017, Iop Publishing Ltd: Bristol.</li><li><strong>Zhang, H., et al., Applications of nonlocal means algorithm in low-dose X-ray CT image processing and reconstruction: A review. Medical Physics, 2017. 44(3): p. 1168-1185.</strong></li><li>Beister, M., D. Kolditz, and W.A. Kalender, Iterative reconstruction methods in X-ray CT. Physica Medica-European Journal of Medical Physics, 2012. 28: p. 94-108.</li><li><strong>van Aarle, W., et al., Fast and flexible X-ray tomography using the ASTRA toolbox. Optics Express, 2016. 24: p. 25129-25147.</strong></li><li>Parikh, N. and S. Boyd, Proximal Algorithms. Found. Trends Optim., 2014. 1: p. 127–239.</li><li>Pan, X., E.Y. Sidky, and M. Vannier, Why do commercial CT scanners still employ traditional, filtered back-projection for image reconstruction? Inverse Problems, 2009. 25: p. 123009.</li><li><strong>Chambolle, A. and T. Pock, An introduction to continuous optimization for imaging. Acta Numerica, 2016. 25: p. 161-319.</strong></li><li><strong>Chambolle, A. and T. Pock, A First-Order Primal-Dual Algorithm for Convex Problems with Applications to Imaging. Journal of Mathematical Imaging and Vision, 2011. 40: p. 120-145.</strong></li><li>index_of_articals.pdf</li><li>Schuhbaeck, A., et al., Image quality of ultra-low radiation exposure coronary CT angiography with an effective dose &lt;0.1 mSv using high-pitch spiral acquisition and raw data-based iterative reconstruction. European Radiology, 2013. 23: p. 597-606.</li><li>Richard, S., et al., Towards task-based assessment of CT performance: system and object MTF across different reconstruction algorithms. Medical Physics, 2012. 39: p. 4115-4122.</li><li>Kang, E., J. Min, and J.C. Ye, A deep convolutional neural network using directional wavelets for low-dose X-ray CT reconstruction. arXiv:1610.09736 [cs], 2016.</li><li>Kalra, M.K., et al., Radiation dose reduction with Sinogram Affirmed Iterative Reconstruction technique for abdominal computed tomography. Journal of Computer Assisted Tomography, 2012. 36: p. 339-346.</li><li>Chen, B., et al., An Open Library of CT Patient Projection Data. Proceedings of SPIE–the International Society for Optical Engineering, 2016. 9783.</li><li>Baker, M.E., et al., Contrast-to-noise ratio and low-contrast object resolution on full- and low-dose MDCT: SAFIRE versus filtered back projection in a low-contrast object phantom and in the liver. AJR. American journal of roentgenology, 2012. 199: p. 8-18.</li><li><strong>李树涛, 魏., 压缩传感综述. 自动化学报, 2009. 03(011)）: p. 1369-1377.</strong></li><li>Zhu, M. and T.F. Chan, An efficient primal-dual hybrid gradient algorithm for total variation image restoration. Ucla Cam Report, 2008.</li><li>Palenstijn, W.J., K. Batenburg, and J. Sijbers, Performance improvements for iterative electron tomography reconstruction using graphics processing units (GPUs). Journal of structural biology, 2011. 176: p. 250-3.</li><li>He, B. and X. Yuan, Convergence analysis of primal-dual algorithms for total variation image restoration. 2010.</li><li><strong>Gürsoy, D., et al., TomoPy: a framework for the analysis of synchrotron tomographic data. Journal of Synchrotron Radiation, 2014. 21: p. 1188-1193.</strong></li><li>Singh, S., et al., Comparison of hybrid and pure iterative reconstruction techniques with conventional filtered back projection: dose reduction potential in the abdomen. Journal of Computer Assisted Tomography, 2012. 36: p. 347-353.</li><li>Baumueller, S., et al., Low-dose CT of the lung: potential value of iterative reconstructions. European Radiology, 2012. 22: p. 2597-2606.</li><li>Zeng, G.L., A fast method to emulate an iterative POCS image reconstruction algorithm. Medical Physics, 2017. 44: p. e353-e359.</li><li>Xu, Q., et al., Low-dose X-ray CT reconstruction via dictionary learning. IEEE transactions on medical imaging, 2012. 31: p. 1682-1697.</li><li>McCollough, C.H., et al., Achieving Routine Submillisievert CT Scanning: Report from the Summit on Management of Radiation Dose in CT. Radiology, 2012. 264: p. 567-580.</li><li>Kim, K., G. El Fakhri, and Q. Li, Low-dose CT reconstruction using spatially encoded nonlocal penalty. Medical Physics, 2017. 44: p. e376-e390.</li><li><strong>Boyd, S. and L. Vandenberghe, Convex Optimization. 1 edition ed. 2004, Cambridge, UK ; New York: Cambridge University Press. 727.</strong></li><li><strong>Rockafellar, R.T., Convex Analysis. Reprint ed. 1997, Princeton, NJ: Princeton University Press. 472.</strong></li><li>Arrow, K.J., L. Hurwicz, and H. Uzawa, Studies in linear and non-linear programming,. 1st edition ed. 1958: Stanford University Press. 229.</li></ol>]]></content>
      
      
      <categories>
          
          <category> optimization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> optimization </tag>
            
            <tag> ct reconstruction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch: 数据加载和处理</title>
      <link href="/2018/03/02/pytorch-data-loading-and-processing/"/>
      <url>/2018/03/02/pytorch-data-loading-and-processing/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>结合<a href="http://pytorch.org/tutorials/beginner/data_loading_tutorial.html#sphx-glr-beginner-data-loading-tutorial-py" target="_blank" rel="noopener">官方tutorials</a>和<a href="https://github.com/pytorch" target="_blank" rel="noopener">源码</a>以及部分博客写出此文。</p><a id="more"></a><p><code>pytorch</code>的数据加载和处理相对容易的多，常见的两种形式的导入：</p><ol><li>一种是整个数据集都在一个文件夹下，内部再另附一个label文件，说明每个文件夹的状态，如这个<a href="https://download.pytorch.org/tutorial/faces.zip" target="_blank" rel="noopener">数据库</a>。这种存放数据的方式可能更适合在<strong>非分类</strong>问题上得到应用。</li><li>一种则是更适合使用在<strong>分类</strong>问题上，即把不同种类的数据分为不同的文件夹存放起来。其形式如下：<blockquote><p>root/ants/xxx.png<br>root/ants/xxy.jpeg<br>root/ants/xxz.png<br>.<br>.<br>.<br>root/bees/123.jpg<br>root/bees/nsdf3.png<br>root/bees/asd932_.png</p></blockquote></li></ol><p>本文首先结合<a href="http://pytorch.org/tutorials/beginner/data_loading_tutorial.html#sphx-glr-beginner-data-loading-tutorial-py" target="_blank" rel="noopener">官方turorials</a>介绍<strong>第一种</strong>方法，以了解其数据加载的原理；然后以代码形式简单介绍<strong>第二种</strong>方法。其中第二种方法和第一种方法的原理相同，其差别在于第二种方法运用了<code>trochvision</code>中提供的已写好的工具<code>ImageFolder</code>，因此实现起来更为简单。</p><h1 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h1><h2 id="Dataset-class"><a href="#Dataset-class" class="headerlink" title="Dataset class"></a>Dataset class</h2><p><code>torch.utils.data.Dataset</code>是一个抽象类，用户想要加载自定义的数据只需要继承这个类，并且覆写其中的两个方法即可：</p><ol><li><code>__len__</code>:　覆写这个方法使得<code>len(dataset)</code>可以返回整个数据集的大小</li><li><code>__getitem__</code>:　覆写这个方法使得<code>dataset[i]</code>可以返回数据集中第<code>i</code>个样本</li><li>不覆写这两个方法会直接返回错误，其源码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br></pre></td></tr></table></figure>这里我随便从网上下载了20张图像，10张小猫，10张小狗。为了省事儿(只是想验证下继承<code>Dataset</code>类是否好用)，我没有给数据集增加标签文件，而是直接把1-10号定义为小猫，11-20号定义为小狗，这样会给<code>__len__</code>和<code>__getitem__</code>减小麻烦，其目录结构如下：<img src="/2018/03/02/pytorch-data-loading-and-processing/tree.png" class="">建立的自定义类如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader, Dataset</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, transform</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalData</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root_dir, transform=None)</span>:</span></span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.transform = transform</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, idx)</span>:</span></span><br><span class="line">        filenames = os.listdir(self.root_dir)</span><br><span class="line">        filename = filenames[idx]</span><br><span class="line">        img = io.imread(os.path.join(self.root_dir, filename))</span><br><span class="line">        <span class="comment"># print filename[:-5]</span></span><br><span class="line">        <span class="keyword">if</span> (int(filename[:<span class="number">-5</span>]) &gt; <span class="number">10</span>):</span><br><span class="line">            lable = np.array([<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            lable = np.array([<span class="number">1</span>])</span><br><span class="line">        sample = &#123;<span class="string">'image'</span>: img, <span class="string">'lable'</span>:lable&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            sample = self.transform(sample)</span><br><span class="line">        <span class="keyword">return</span> sample</span><br></pre></td></tr></table></figure><h2 id="Transforms-amp-Compose-transforms"><a href="#Transforms-amp-Compose-transforms" class="headerlink" title="Transforms &amp; Compose transforms"></a>Transforms &amp; Compose transforms</h2></li></ol><p>可以注意到上一节中<code>AnimalData</code>类中<code>__init__</code>中有个<code>transform</code>参数，这也是这一节中要讲清楚的问题。<br>从网上随便下载的图片必然大小不一，而<code>cnn</code>的结构却要求输入图像要有固定的大小；<code>numpy</code>中的图像通道定义为<code>H, W, C</code>，而<code>pytorch</code>中的通道定义为<code>C, H, W</code>; <code>pytorch</code>中输入数据需要将<code>numpy array</code>改为<code>tensor</code>类型；输入数据往往需要归一化，等等。<br>基于以上考虑，我们可以自定义一些<code>Callable</code>的类，然后作为<code>trasform</code>参数传递给上一节定义的<code>dataset</code>类。为了更加方便，<code>torchvision.transforms.Compose</code>提供了Compose类，可以一次性将我们自定义的<code>callable</code>类传递给<code>dataset</code>类，直接得到转换后的数据。<br>这里我直接<code>copy</code>了<a href="http://pytorch.org/tutorials/beginner/data_loading_tutorial.html#sphx-glr-beginner-data-loading-tutorial-py" target="_blank" rel="noopener">教程</a>上的三个类：<code>Rescale</code>, <code>RandomCrop</code>, <code>ToTensor</code>,稍作改动，适应我的数据库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rescale</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Rescale the image in a sample to a given size.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        output_size (tuple or int): Desired output size. If tuple, output is</span></span><br><span class="line"><span class="string">            matched to output_size. If int, smaller of image edges is matched</span></span><br><span class="line"><span class="string">            to output_size keeping aspect ratio the same.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_size)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(output_size, (int, tuple))</span><br><span class="line">        self.output_size = output_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line">        image, lable = sample[<span class="string">'image'</span>], sample[<span class="string">'lable'</span>]</span><br><span class="line"></span><br><span class="line">        h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">if</span> isinstance(self.output_size, int):</span><br><span class="line">            <span class="keyword">if</span> h &gt; w:</span><br><span class="line">                new_h, new_w = self.output_size * h / w, self.output_size</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_h, new_w = self.output_size, self.output_size * w / h</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_h, new_w = self.output_size</span><br><span class="line"></span><br><span class="line">        new_h, new_w = int(new_h), int(new_w)</span><br><span class="line"></span><br><span class="line">        img = transform.resize(image, (new_h, new_w))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># h and w are swapped for lable because for images,</span></span><br><span class="line">        <span class="comment"># x and y axes are axis 1 and 0 respectively</span></span><br><span class="line">        <span class="comment"># lable = lable * [new_w / w, new_h / h]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'image'</span>: img, <span class="string">'lable'</span>: lable&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomCrop</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Crop randomly the image in a sample.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        output_size (tuple or int): Desired output size. If int, square crop</span></span><br><span class="line"><span class="string">            is made.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output_size)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(output_size, (int, tuple))</span><br><span class="line">        <span class="keyword">if</span> isinstance(output_size, int):</span><br><span class="line">            self.output_size = (output_size, output_size)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> len(output_size) == <span class="number">2</span></span><br><span class="line">            self.output_size = output_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line">        image, lable = sample[<span class="string">'image'</span>], sample[<span class="string">'lable'</span>]</span><br><span class="line"></span><br><span class="line">        h, w = image.shape[:<span class="number">2</span>]</span><br><span class="line">        new_h, new_w = self.output_size</span><br><span class="line"></span><br><span class="line">        top = np.random.randint(<span class="number">0</span>, h - new_h)</span><br><span class="line">        left = np.random.randint(<span class="number">0</span>, w - new_w)</span><br><span class="line"></span><br><span class="line">        image = image[top: top + new_h,</span><br><span class="line">                      left: left + new_w]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># lable = lable - [left, top]</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'image'</span>: image, <span class="string">'lable'</span>: lable&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToTensor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Convert ndarrays in sample to Tensors."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line">        image, lable = sample[<span class="string">'image'</span>], sample[<span class="string">'lable'</span>]</span><br><span class="line">        <span class="comment"># print lable</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># swap color axis because</span></span><br><span class="line">        <span class="comment"># numpy image: H x W x C</span></span><br><span class="line">        <span class="comment"># torch image: C X H X W</span></span><br><span class="line">        image = image.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'image'</span>: torch.from_numpy(image),</span><br><span class="line">                <span class="string">'lable'</span>: torch.from_numpy(lable)&#125;</span><br></pre></td></tr></table></figure><p>定义好<code>callable</code>类之后，通过<code>torchvision.transforms.Compose</code>将上述三个类结合在一起，传递给<code>AnimalData</code>类中的<code>transform</code>参数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trsm = transforms.Compose([Rescale(<span class="number">256</span>),</span><br><span class="line">                            RandomCrop(<span class="number">224</span>),</span><br><span class="line">                            ToTensor()])</span><br><span class="line">data = AnimalData(<span class="string">'./all'</span>, transform=trsm)</span><br></pre></td></tr></table></figure><h2 id="Iterating-through-the-dataset"><a href="#Iterating-through-the-dataset" class="headerlink" title="Iterating through the dataset"></a>Iterating through the dataset</h2><p>上一节中得到<code>data</code>实例之后可以通过<code>for</code>循环来一个一个读取数据，现在这是效率低下的。<code>torch.utils.data.DadaLoader</code>类解决了上述问题。其主要有如下特点：</p><ul><li>Batching the data</li><li>Shuffling the data</li><li>Load the data in parallel using <code>multiprocessing</code> workers.</li></ul><p>实现起来也很简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataloader = DataLoader(data, batch_size=<span class="number">4</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i_batch, bach_data <span class="keyword">in</span> enumerate(dataloader):</span><br><span class="line">    <span class="keyword">print</span> i_batch </span><br><span class="line">    <span class="keyword">print</span> bach_data[<span class="string">'image'</span>].size()</span><br><span class="line">    <span class="keyword">print</span> bach_data[<span class="string">'lable'</span>]</span><br></pre></td></tr></table></figure><h1 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h1><h2 id="torchvision"><a href="#torchvision" class="headerlink" title="torchvision"></a>torchvision</h2><p><code>pytorch</code>几乎将上述所有工作都封装起来供我们使用，其中一个工具就是<code>torchvision.datasets.ImageFolder</code>,用于加载用户自定义的数据，要求我们的数据要有如下结构：</p><blockquote><p>root/ants/xxx.png<br>root/ants/xxy.jpeg<br>root/ants/xxz.png<br>.<br>.<br>.<br>root/bees/123.jpg<br>root/bees/nsdf3.png<br>root/bees/asd932_.png</p></blockquote><p><code>torchvision.transforms</code>中也封装了各种各样的数据处理的工具，如<code>Resize</code>, <code>ToTensor</code>等等功能供我们使用。<br>修改我下载的数据库结构如下：</p><img src="/2018/03/02/pytorch-data-loading-and-processing/method2_tree.png" class=""><p>加载数据代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, utils</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line">train_data = datasets.ImageFolder(<span class="string">'./data1'</span>, transform=transforms.Compose([</span><br><span class="line">    transforms.RandomResizedCrop(<span class="number">224</span>),</span><br><span class="line">    transforms.RandomHorizontalFlip(),</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_data,</span><br><span class="line">                                            batch_size=<span class="number">4</span>,</span><br><span class="line">                                            shuffle=<span class="literal">True</span>,</span><br><span class="line">                                            )</span><br><span class="line">                                            </span><br><span class="line"><span class="keyword">print</span> len(train_loader)</span><br><span class="line"><span class="keyword">for</span> i_batch, img <span class="keyword">in</span> enumerate(train_loader):</span><br><span class="line">    <span class="keyword">if</span> i_batch == <span class="number">0</span>:</span><br><span class="line">        print(img[<span class="number">1</span>])</span><br><span class="line">        fig = plt.figure()</span><br><span class="line">        grid = utils.make_grid(img[<span class="number">0</span>])</span><br><span class="line">        plt.imshow(grid.numpy().transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br><span class="line">        plt.show()</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>结果图：</p><img src="/2018/03/02/pytorch-data-loading-and-processing/result.png" class=""><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>最后欣赏一段<code>torchvision</code><a href="https://github.com/pytorch/vision/blob/master/torchvision/datasets/folder.py" target="_blank" rel="noopener">源码</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># vision/torchvision/datasets/folder.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line">IMG_EXTENSIONS = [<span class="string">'.jpg'</span>, <span class="string">'.jpeg'</span>, <span class="string">'.png'</span>, <span class="string">'.ppm'</span>, <span class="string">'.bmp'</span>, <span class="string">'.pgm'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_image_file</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="string">"""Checks if a file is an image.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        filename (string): path to a file</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        bool: True if the filename ends with a known image extension</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    filename_lower = filename.lower()</span><br><span class="line">    <span class="keyword">return</span> any(filename_lower.endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> IMG_EXTENSIONS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_classes</span><span class="params">(dir)</span>:</span></span><br><span class="line">    classes = [d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(dir) <span class="keyword">if</span> os.path.isdir(os.path.join(dir, d))]</span><br><span class="line">    classes.sort()</span><br><span class="line">    class_to_idx = &#123;classes[i]: i <span class="keyword">for</span> i <span class="keyword">in</span> range(len(classes))&#125;</span><br><span class="line">    <span class="keyword">return</span> classes, class_to_idx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_dataset</span><span class="params">(dir, class_to_idx)</span>:</span></span><br><span class="line">    images = []</span><br><span class="line">    dir = os.path.expanduser(dir)</span><br><span class="line">    <span class="keyword">for</span> target <span class="keyword">in</span> sorted(os.listdir(dir)):</span><br><span class="line">        d = os.path.join(dir, target)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(d):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> root, _, fnames <span class="keyword">in</span> sorted(os.walk(d)):</span><br><span class="line">            <span class="keyword">for</span> fname <span class="keyword">in</span> sorted(fnames):</span><br><span class="line">                <span class="keyword">if</span> is_image_file(fname):</span><br><span class="line">                    path = os.path.join(root, fname)</span><br><span class="line">                    item = (path, class_to_idx[target])</span><br><span class="line">                    images.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> images</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pil_loader</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="comment"># open path as file to avoid ResourceWarning (https://github.com/python-pillow/Pillow/issues/835)</span></span><br><span class="line">    <span class="keyword">with</span> open(path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img = Image.open(f)</span><br><span class="line">        <span class="keyword">return</span> img.convert(<span class="string">'RGB'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accimage_loader</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> accimage</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> accimage.Image(path)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="comment"># Potentially a decoding problem, fall back to PIL.Image</span></span><br><span class="line">        <span class="keyword">return</span> pil_loader(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">default_loader</span><span class="params">(path)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> torchvision <span class="keyword">import</span> get_image_backend</span><br><span class="line">    <span class="keyword">if</span> get_image_backend() == <span class="string">'accimage'</span>:</span><br><span class="line">        <span class="keyword">return</span> accimage_loader(path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> pil_loader(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageFolder</span><span class="params">(data.Dataset)</span>:</span></span><br><span class="line">    <span class="string">"""A generic data loader where the images are arranged in this way: ::</span></span><br><span class="line"><span class="string">        root/dog/xxx.png</span></span><br><span class="line"><span class="string">        root/dog/xxy.png</span></span><br><span class="line"><span class="string">        root/dog/xxz.png</span></span><br><span class="line"><span class="string">        root/cat/123.png</span></span><br><span class="line"><span class="string">        root/cat/nsdf3.png</span></span><br><span class="line"><span class="string">        root/cat/asd932_.png</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        root (string): Root directory path.</span></span><br><span class="line"><span class="string">        transform (callable, optional): A function/transform that  takes in an PIL image</span></span><br><span class="line"><span class="string">            and returns a transformed version. E.g, ``transforms.RandomCrop``</span></span><br><span class="line"><span class="string">        target_transform (callable, optional): A function/transform that takes in the</span></span><br><span class="line"><span class="string">            target and transforms it.</span></span><br><span class="line"><span class="string">        loader (callable, optional): A function to load an image given its path.</span></span><br><span class="line"><span class="string">     Attributes:</span></span><br><span class="line"><span class="string">        classes (list): List of the class names.</span></span><br><span class="line"><span class="string">        class_to_idx (dict): Dict with items (class_name, class_index).</span></span><br><span class="line"><span class="string">        imgs (list): List of (image path, class_index) tuples</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, transform=None, target_transform=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 loader=default_loader)</span>:</span></span><br><span class="line">        classes, class_to_idx = find_classes(root)</span><br><span class="line">        imgs = make_dataset(root, class_to_idx)</span><br><span class="line">        <span class="keyword">if</span> len(imgs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span>(RuntimeError(<span class="string">"Found 0 images in subfolders of: "</span> + root + <span class="string">"\n"</span></span><br><span class="line">                               <span class="string">"Supported image extensions are: "</span> + <span class="string">","</span>.join(IMG_EXTENSIONS)))</span><br><span class="line"></span><br><span class="line">        self.root = root</span><br><span class="line">        self.imgs = imgs</span><br><span class="line">        self.classes = classes</span><br><span class="line">        self.class_to_idx = class_to_idx</span><br><span class="line">        self.transform = transform</span><br><span class="line">        self.target_transform = target_transform</span><br><span class="line">        self.loader = loader</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            index (int): Index</span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">            tuple: (image, target) where target is class_index of the target class.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        path, target = self.imgs[index]</span><br><span class="line">        img = self.loader(path)</span><br><span class="line">        <span class="keyword">if</span> self.transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="keyword">if</span> self.target_transform <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            target = self.target_transform(target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> img, target</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.imgs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt_str = <span class="string">'Dataset '</span> + self.__class__.__name__ + <span class="string">'\n'</span></span><br><span class="line">        fmt_str += <span class="string">'    Number of datapoints: &#123;&#125;\n'</span>.format(self.__len__())</span><br><span class="line">        fmt_str += <span class="string">'    Root Location: &#123;&#125;\n'</span>.format(self.root)</span><br><span class="line">        tmp = <span class="string">'    Transforms (if any): '</span></span><br><span class="line">        fmt_str += <span class="string">'&#123;0&#125;&#123;1&#125;\n'</span>.format(tmp, self.transform.__repr__().replace(<span class="string">'\n'</span>, <span class="string">'\n'</span> + <span class="string">' '</span> * len(tmp)))</span><br><span class="line">        tmp = <span class="string">'    Target Transforms (if any): '</span></span><br><span class="line">        fmt_str += <span class="string">'&#123;0&#125;&#123;1&#125;'</span>.format(tmp, self.target_transform.__repr__().replace(<span class="string">'\n'</span>, <span class="string">'\n'</span> + <span class="string">' '</span> * len(tmp)))</span><br><span class="line">        <span class="keyword">return</span> fmt_str</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1]. <a href="http://pytorch.org/tutorials/beginner/data_loading_tutorial.html#sphx-glr-beginner-data-loading-tutorial-py" target="_blank" rel="noopener">Data Loading and Processing Tutorial</a><br>[2]. <a href="https://github.com/pytorch/pytorch/blob/master/torch/utils/data/dataset.py" target="_blank" rel="noopener">github: pytorch/torch/utils/data/dataset.py</a><br>[3]. <a href="https://github.com/pytorch/vision/blob/master/torchvision/datasets/folder.py" target="_blank" rel="noopener">github: vision/torchvision/datasets/folder.py</a><br>[4]. <a href="http://blog.csdn.net/marsjhao/article/details/72055310" target="_blank" rel="noopener">csdn</a></p>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> pytorch </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learning python: arguments(参数)</title>
      <link href="/2018/03/01/python-arguments/"/>
      <url>/2018/03/01/python-arguments/</url>
      
        <content type="html"><![CDATA[<h1 id="Argument-Matching-Basics"><a href="#Argument-Matching-Basics" class="headerlink" title="Argument Matching Basics"></a>Argument Matching Basics</h1><ol><li><strong>Positionals</strong>: matched from left to right</li><li><strong>Keywords</strong>: matched by argument name</li><li><strong>Defaults</strong>: specify values for optional arguments that aren’t passed</li><li><strong>Varargs collecting</strong>: collect arbitrarily many positional or keyword arguments</li><li><strong>Varargs unpacking</strong>: pass arbitrarily many positional or keyword arguments</li><li><strong>Keyword-only argument</strong>s: arguments that must be passed by name(onyl support 3.x but not 2.x)</li></ol><a id="more"></a><h1 id="Argument-Matching-Syntax"><a href="#Argument-Matching-Syntax" class="headerlink" title="Argument Matching Syntax"></a>Argument Matching Syntax</h1><table><thead><tr><th align="left">Syntax</th><th align="left">Location</th><th align="left">Interpretation</th></tr></thead><tbody><tr><td align="left">func(value)</td><td align="left">Caller</td><td align="left">Normal argument:matched by position</td></tr><tr><td align="left">func(name=value)</td><td align="left">Caller</td><td align="left">Keyword argument: matched by name</td></tr><tr><td align="left">func(*iterable)</td><td align="left">Caller</td><td align="left">Pass all objects in <em>iterable as</em> individual positional arguments</td></tr><tr><td align="left">func(**dict)</td><td align="left">Caller</td><td align="left">Pass all key/value pairs in <em>dict</em> as individual keyword arguments</td></tr><tr><td align="left">def func(name)</td><td align="left">Function</td><td align="left">Normal argument: matches any passed value by position or name</td></tr><tr><td align="left">def func(name=value)</td><td align="left">Function</td><td align="left">Default argument value, if not passed in the call</td></tr><tr><td align="left">def func(*name)</td><td align="left">Function</td><td align="left">Matches and collects remaining positional arguments in a tuple</td></tr><tr><td align="left">def func(**name)</td><td align="left">Function</td><td align="left">Matches and collects remaining keyword arguments in a dictionary</td></tr><tr><td align="left">def func(*other, name)</td><td align="left">Function</td><td align="left">Arguments that must be passed by keyword only in calls (3.X)</td></tr><tr><td align="left">def func(*, name=value)</td><td align="left">Function</td><td align="left">Arguments that must be passed by keyword only in calls (3.X)</td></tr></tbody></table><h1 id="The-Gritty-Details"><a href="#The-Gritty-Details" class="headerlink" title="The Gritty Details"></a>The Gritty Details</h1><p>Python will ask you to follow these ordering rules among the modes’ optional components:</p><ul><li>In a function <strong><em>call</em></strong>, arguments must appear in this order: any positional arguments <strong>(value)</strong>; followed by a combination of any keyword arguments <strong>(name=value)</strong> and the <strong>*iterable</strong> form; followed by the <strong>**dict</strong> form.</li><li>In a function <strong><em>header</em></strong>, arguments must appear in this order: any normal arguments <strong>(name)</strong>; followed by any default arguments <strong>(name=value)</strong>; followed by the <strong>*name</strong> (or * in 3.X) form; followed by any <strong>name</strong> or <strong>name=value</strong> keyword-only arguments (in 3.X); followed by the <strong>**name</strong> form.</li></ul><p>The steps that Python internally carries out to match arguments before assignment can roughly be described as follows:</p><ol><li>Assign nonkeyword arguments by position.</li><li>Assign keyword arguments by matching names.</li><li>Assign extra nonkeyword arguments to <strong>*name</strong> tuple.</li><li>Assign extra keyword arguments to <strong>**name</strong> dictionary.</li><li>Assign default values to unassigned arguments in header.</li></ol><p>After this, Python checks to make sure each argument is passed just one value; if not, an error is raised. When all matching is complete, Python assigns argument names to the objects passed to them.</p><h2 id="Keyword-and-Default-Examples"><a href="#Keyword-and-Default-Examples" class="headerlink" title="Keyword and Default Examples"></a>Keyword and Default Examples</h2><p>we define a function like this:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(c=<span class="number">3</span>, b=<span class="number">2</span>, a=<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, c=<span class="number">3</span>, b=<span class="number">2</span>) <span class="comment"># a gets 1 by position, b and c passed by name</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="Defaults"><a href="#Defaults" class="headerlink" title="Defaults"></a>Defaults</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b=<span class="number">2</span>, c=<span class="number">3</span>)</span>:</span> print(a, b, c) <span class="comment"># a required, b and c potional</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;　f(a=<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, c=<span class="number">6</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Combining-Keywords-and-Defaults"><a href="#Combining-Keywords-and-Defaults" class="headerlink" title="Combining Keywords and Defaults"></a>Combining Keywords and Defaults</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(spam, eggs, toast=<span class="number">0</span>, ham=<span class="number">0</span>)</span>:</span>   <span class="comment"># First 2 required</span></span><br><span class="line">    print((spam, eggs, toast, ham))</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)                              <span class="comment"># Output: (1, 2, 0, 0)</span></span><br><span class="line">func(<span class="number">1</span>, ham=<span class="number">1</span>, eggs=<span class="number">0</span>)                  <span class="comment"># Output: (1, 0, 0, 1)</span></span><br><span class="line">func(spam=<span class="number">1</span>, eggs=<span class="number">0</span>)                    <span class="comment"># Output: (1, 0, 0, 0)</span></span><br><span class="line">func(toast=<span class="number">1</span>, eggs=<span class="number">2</span>, spam=<span class="number">3</span>)           <span class="comment"># Output: (3, 2, 1, 0)</span></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)                        <span class="comment"># Output: (1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure><h2 id="Arbitrary-Arguments-Examples"><a href="#Arbitrary-Arguments-Examples" class="headerlink" title="Arbitrary Arguments Examples"></a>Arbitrary Arguments Examples</h2><p>The last two matching extensions, * and **, are designed to support functions that take <strong><em>any number</em></strong> of arguments. Both can appear in either the function definition or a function call, and they have related purposes in the two locations.</p><h3 id="Headers-Collecting-arguments"><a href="#Headers-Collecting-arguments" class="headerlink" title="Headers: Collecting arguments"></a>Headers: Collecting arguments</h3><p><strong>*args</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args)</span>:</span> print(args)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line">()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>**args</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(**args)</span>:</span> print(args)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>mixed</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, *pargs, **kargs)</span>:</span> print(a, pargs, kargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">1</span>, y=<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span> (<span class="number">2</span>, <span class="number">3</span>) &#123;<span class="string">'y'</span>: <span class="number">2</span>, <span class="string">'x'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="Calls-Unpacking-arguments"><a href="#Calls-Unpacking-arguments" class="headerlink" title="Calls: Unpacking arguments"></a>Calls: Unpacking arguments</h3><p><strong>*args</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c, d)</span>:</span> print(a, b, c, d)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args += (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(*args)         <span class="comment"># Same as func(1, 2, 3, 4)</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>**args</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(**args)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>mixed</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(*(<span class="number">1</span>, <span class="number">2</span>), **&#123;<span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;)   <span class="comment"># Same as func(1, 2, d=4, c=3)</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>), **&#123;<span class="string">'d'</span>: <span class="number">4</span>&#125;)        <span class="comment"># Same as func(1, 2, 3, d=4)</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, c=<span class="number">3</span>, *(<span class="number">2</span>,), **&#123;<span class="string">'d'</span>: <span class="number">4</span>&#125;)     <span class="comment"># Same as func(1, 2, c=3, d=4)</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, *(<span class="number">2</span>, <span class="number">3</span>), d=<span class="number">4</span>)               <span class="comment"># Same as func(1, 2, 3, d=4)</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(<span class="number">1</span>, *(<span class="number">2</span>,), c=<span class="number">3</span>, **&#123;<span class="string">'d'</span>:<span class="number">4</span>&#125;)      <span class="comment"># Same as func(1, 2, c=3, d=4)</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><em>N.B.</em>: this article is originally from the book learning python<strong>[1]</strong></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1]. <a href="https://book.douban.com/subject/22139956/" target="_blank" rel="noopener">Learning Python, 5th Edition</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deep learning: convolution arithmetic</title>
      <link href="/2018/02/26/convolution-arithmetic/"/>
      <url>/2018/02/26/convolution-arithmetic/</url>
      
        <content type="html"><![CDATA[<h1 id="Convolution-arithmetic"><a href="#Convolution-arithmetic" class="headerlink" title="Convolution arithmetic"></a>Convolution arithmetic</h1><p>A technical report on convolution arithmetic in the context of deep learning.</p><h2 id="Convolution-animations"><a href="#Convolution-animations" class="headerlink" title="Convolution animations"></a>Convolution animations</h2><p><em>N.B.: Blue maps are inputs, and cyan maps are outputs.</em></p><a id="more"></a><table><thead><tr><th align="center">No padding, no strides</th><th align="center">Arbitrary padding, no strides</th><th align="center">Half padding, no strides</th></tr></thead><tbody><tr><td align="center"><img src="/2018/02/26/convolution-arithmetic/no_padding_no_strides.gif" class="" width="200" height="200"></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/arbitrary_padding_no_strides.gif" class="" width="200" height="200"></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/same_padding_no_strides.gif" class="" width="200" height="200"></td></tr><tr><td align="center">Full padding, no strides</td><td align="center">No padding, strides</td><td align="center">Padding, strides</td></tr><tr><td align="center"><img src="/2018/02/26/convolution-arithmetic/full_padding_no_strides.gif" class="" width="200" height="200"></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/no_padding_strides.gif" class=""></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/padding_strides.gif" class=""></td></tr><tr><td align="center">Padding, strides (odd)</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><img src="/2018/02/26/convolution-arithmetic/padding_strides_odd.gif" class="" width="200" height="200"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="Transposed-convolution-animations"><a href="#Transposed-convolution-animations" class="headerlink" title="Transposed convolution animations"></a>Transposed convolution animations</h2><p><em>N.B.: Blue maps are inputs, and cyan maps are outputs.</em></p><table><thead><tr><th align="center">No padding, no strides, transposed</th><th align="center">Arbitrary padding, no strides, transposed</th><th align="center">Half padding, no strides, transposed</th></tr></thead><tbody><tr><td align="center"><img src="/2018/02/26/convolution-arithmetic/no_padding_no_strides_transposed.gif" class=""></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/arbitrary_padding_no_strides_transposed.gif" class=""></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/same_padding_no_strides_transposed.gif" class=""></td></tr><tr><td align="center">Full padding, no strides, transposed</td><td align="center">No padding, strides, transposed</td><td align="center">Padding, strides, transposed</td></tr><tr><td align="center"><img src="/2018/02/26/convolution-arithmetic/full_padding_no_strides_transposed.gif" class=""></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/no_padding_strides_transposed.gif" class=""></td><td align="center"><img src="/2018/02/26/convolution-arithmetic/padding_strides_transposed.gif" class=""></td></tr><tr><td align="center">Padding, strides, transposed (odd)</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><img src="/2018/02/26/convolution-arithmetic/padding_strides_odd_transposed.gif" class=""></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="Dilated-convolution-animations"><a href="#Dilated-convolution-animations" class="headerlink" title="Dilated convolution animations"></a>Dilated convolution animations</h2><p><em>N.B.: Blue maps are inputs, and cyan maps are outputs.</em></p><p>No padding, no stride, dilation||<br>:-:|:-:|:-:</p><img src="/2018/02/26/convolution-arithmetic/dilation.gif" class="" width="200" height="200">||<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><blockquote><p>[1.] Vincent Dumoulin, Francesco Visin - <a href="https://arxiv.org/abs/1603.07285" target="_blank" rel="noopener">A guide to convolution arithmetic for deep learning</a><br>[2.] <a href="https://cs231n.github.io/convolutional-networks/" target="_blank" rel="noopener">https://cs231n.github.io/convolutional-networks/</a><br>[3.] <a href="https://github.com/vdumoulin/conv_arithmetic" target="_blank" rel="noopener">https://github.com/vdumoulin/conv_arithmetic</a></p></blockquote><div class="pdf" target="1603.07285.pdf" height=""></div>]]></content>
      
      
      <categories>
          
          <category> deep learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> pytorch </tag>
            
            <tag> cnn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>optimization: Infimum and Supremum</title>
      <link href="/2018/02/25/Infimum-and-Supremum/"/>
      <url>/2018/02/25/Infimum-and-Supremum/</url>
      
        <content type="html"><![CDATA[<p>首先要从下界（<a href="https://en.wikipedia.org/wiki/Upper_and_lower_bounds" target="_blank" rel="noopener">lower bound</a>）和上界(<a href="https://en.wikipedia.org/wiki/Upper_and_lower_bounds" target="_blank" rel="noopener">upper bound</a>)讲起。</p><a id="more"></a><h1 id="lower-bound-下界"><a href="#lower-bound-下界" class="headerlink" title="lower bound (下界)"></a>lower bound (下界)</h1><p>定义：<br>A <strong>lower bound</strong> of a subset $S$ of a partially ordered set $(P,≤)$ is an element a of $P$ such that</p><blockquote><p>$ a \le x $ for all $ x $ in $ S $<br>从下界的定义可以看出，一个集合的下界可以有任意多个，</p></blockquote><h1 id="upper-bound-（上界）"><a href="#upper-bound-（上界）" class="headerlink" title="upper bound （上界）"></a>upper bound （上界）</h1><p>定义：<br>An <strong>upper bound</strong> of a subset  $ S $ of a partially ordered set $ (P,≤) $ is an element $ b $ of $ P $ such that</p><blockquote><p>$ b \ge x $ for all $ x $ in $ S $.<br>同理，一个集合的上界也可以有任意多个。</p></blockquote><h1 id="Infimum-下确界"><a href="#Infimum-下确界" class="headerlink" title="Infimum (下确界)"></a>Infimum (下确界)</h1><p>定义：<br>A lower bound a of $ S $ is called an <strong>infimum</strong> (or greatest lower bound, or meet) of $ S $ if</p><blockquote><p>for all lower bounds $ y $ of $ S $ in $ P $, $ y \le a $ ($ a $ is larger than any other lower bound).</p></blockquote><h1 id="Supremum-上确界"><a href="#Supremum-上确界" class="headerlink" title="Supremum (上确界)"></a>Supremum (上确界)</h1><p>定义：<br>An upper bound $ b $ of $ S $ is called a <strong>supremum</strong> (or least upper bound, or join) of $ S $ if</p><blockquote><p>for all upper bounds $ z $ of $ S $ in $ P $, $ z \ge b $ ($ b $ is less than any other upper bound).</p></blockquote><p>上述定义说明<code>inf</code>和<code>sup</code>有点像<code>min</code>和<code>max</code>，但是使用<code>inf</code>和<code>sup</code>有时候会更严谨，因为有时候集合不一定是闭集合，这样导致可能一个集合的<code>max</code>(或<code>min</code>)不存在，但是其<code>sup</code>（或<code>inf</code>）确是存在的。</p><p>最后用一张图说明<code>sup</code>：</p><img src="/2018/02/25/Infimum-and-Supremum/sup.png" class=""><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Infimum_and_supremum" target="_blank" rel="noopener">维基百科</a></p>]]></content>
      
      
      <categories>
          
          <category> optimization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> optimization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learning python: __future__ 模块</title>
      <link href="/2018/02/19/python-future/"/>
      <url>/2018/02/19/python-future/</url>
      
        <content type="html"><![CDATA[<p>先把<a href="https://docs.python.org/2.7/library/__future__.html" target="_blank" rel="noopener">官网</a>上的描述贴出来：</p><ul><li><p>To avoid confusing existing tools that analyze import statements and expect to find the modules they’re importing.</p></li><li><p>To ensure that future statements run under releases prior to 2.1 at least yield runtime exceptions (the import of <strong>future</strong> will fail, because there was no module of that name prior to 2.1).</p></li><li><p>To document when incompatible changes were introduced, and when they will be — or were — made mandatory. This is a form of executable documentation, and can be inspected programmatically via importing <strong>future</strong> and examining its contents.</p></li></ul><a id="more"></a><p>这段话看得人非常晕，查了一些资料，基本上<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820023084e5263fe54fde4e4e8616597058cc4ba1000" target="_blank" rel="noopener"><strong>廖雪峰</strong>老师</a>的解释我认为是比较合理的。现粘贴如下：</p><hr><p><em>Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。有些改动是不兼容旧版本的，也就是在当前版本运行正常的代码，到下一个版本运行就可能不正常了。</em></p><p><em>从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用’xxx’表示str，Unicode字符串用u’xxx’表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u’xxx’和’xxx’是完全一致的，而在2.x中以’xxx’表示的str就必须写成b’xxx’，以此表示“二进制字符串”。</em></p><p><em>要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。</em></p><p><em>Python提供了<strong>future</strong>模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下：</em></p><p>*为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法： *</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># still running on Python 2.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'\'xxx\' is unicode?'</span>, isinstance(<span class="string">'xxx'</span>, unicode)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'u\'xxx\' is unicode?'</span>, isinstance(<span class="string">u'xxx'</span>, unicode)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'\'xxx\' is str?'</span>, isinstance(<span class="string">'xxx'</span>, str)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b\'xxx\' is str?'</span>, isinstance(<span class="string">b'xxx'</span>, str)</span><br></pre></td></tr></table></figure><p><strong><em>注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的’a string’仍是一个unicode，而加上前缀b的b’a string’才变成了str：</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python task.py</span><br><span class="line"><span class="string">'xxx'</span> is unicode? True</span><br><span class="line">u<span class="string">'xxx'</span> is unicode? True</span><br><span class="line"><span class="string">'xxx'</span> is str? False</span><br><span class="line">b<span class="string">'xxx'</span> is str? True</span><br></pre></td></tr></table></figure><hr><p><strong>参考：</strong></p><ol><li><a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820023084e5263fe54fde4e4e8616597058cc4ba1000" target="_blank" rel="noopener">廖雪峰的官方网站</a></li><li><a href="https://www.jianshu.com/p/14b156c361c4" target="_blank" rel="noopener">https://www.jianshu.com/p/14b156c361c4</a></li><li><a href="https://docs.python.org/2.7/library/__future__.html" target="_blank" rel="noopener">python 官网</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learning python: argparse 模块</title>
      <link href="/2018/02/19/python-argparse/"/>
      <url>/2018/02/19/python-argparse/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当遇到需要参数的情况时，往往有以下<em>三种</em>处理方法[1]:<br><strong>直接给定</strong><br>    这种方法实现起来方便，但是灵活性稍差，每次都需要打开源码修改。<br><strong>手动解析</strong><br>    这种方法也算是比较常用，但是当参数过多时就显示出来不方便了，因为每次输入的格式以及参数的个数都必须一点不差。举个简单的小例子说明这种方法如何使用：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 代码-手动解析参数</span></span><br><span class="line"><span class="comment"># 文件名称test.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> sys.argv[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"end"</span></span><br></pre></td></tr></table></figure><br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$python</span> test.py 1 </span><br><span class="line">test.py </span><br><span class="line">end</span><br></pre></td></tr></table></figure><br><strong>自动解析</strong><br>    相比上述两种方法，这种自动解析的方法更加灵活，且参数可以选择，顺序可以不确定，因此建议使用这种方法。其主要依赖python包<a href="https://docs.python.org/3.4/library/argparse.html#module-argparse" target="_blank" rel="noopener">argparse</a>。</p><a id="more"></a><hr><p>接下来主要介绍python命令行解析模块argparse<strong><em>[2][3]</em></strong>：<br><code>argparse</code> 模块使得用户友好的命令行编程更加方便。首先定义程序中需要什么参数，然后<code>argparse</code>会自动从<code>sys.argv</code>中解析之前定义的参数。<br><code>argparse</code>还可以自动生成帮助文档，并且当用户输入错误的参数时自动报错。</p><h2 id="来个例子"><a href="#来个例子" class="headerlink" title="来个例子"></a>来个例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python代码 - argparse 示例</span></span><br><span class="line"><span class="comment"># 代码名称： prog.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                   help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                   const=sum, default=max,</span><br><span class="line">                   help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure><p>命令行运行如下命令可以查看帮助信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ python prog.py -h</span><br><span class="line">usage: prog.py [-h] [--sum] N [N ...]</span><br><span class="line"></span><br><span class="line">Process some integers.</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line"> N           an <span class="built_in">integer</span> <span class="keyword">for</span> the accumulator</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line"> -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line"> --sum       sum the integers (default: find the max)</span><br></pre></td></tr></table></figure><p>使用合适的参数运行程序，可以得到输入参数的<strong>max</strong>或者<strong>sum</strong>，如果输入不合适的参数，则程序会直接报错，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python prog.py 1 2 3 4</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">$ python prog.py 1 2 3 4 --sum</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">$ python prog.py a b c</span><br><span class="line">usage: prog.py [-h] [--sum] N [N ...]</span><br><span class="line">prog.py: error: argument N: invalid int value: <span class="string">'a'</span></span><br></pre></td></tr></table></figure><h3 id="创建一个解释器"><a href="#创建一个解释器" class="headerlink" title="创建一个解释器"></a>创建一个解释器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br></pre></td></tr></table></figure><p><code>ArgumentParser</code>对象存储了解析命令行参数所需的所有信息。</p><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p><code>add_argument()</code>函数实现了将需要的参数添加到<code>ArgumentParser</code>对象中。<br>这些调用告诉<code>ArgumentParse</code>对象怎样提取命令行中的参数，并如何将其转化为所需的对象。This information is stored and used when <code>parse_args()</code>is called. For example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">&gt;&gt;&gt;parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br></pre></td></tr></table></figure><p>调用完<code>parse_args()</code>函数后会返回两个对象，<code>integers</code>和<code>accumulate</code>。<br><code>integers</code>是一个或多个(list)int型的数；<br><code>accumulate</code>是一个<code>sum()</code>函数(<code>--sum</code>已调用),或者<code>max()</code>(<code>--sum</code>没调用)</p><h3 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parser.parse_args([<span class="string">'--sum'</span>, <span class="string">'7'</span>, <span class="string">'-1'</span>, <span class="string">'42'</span>])</span><br><span class="line">Namespace(accumulate=&lt;built-<span class="keyword">in</span> function sum&gt;, integers=[<span class="number">7</span>, <span class="number">-1</span>, <span class="number">42</span>])</span><br></pre></td></tr></table></figure><p><em>注意： 在一个script中，<code>parse_args()</code>函数一般不带参数直接调用，而参数是直接在命令行中给出，然后<code>ArgumentParser</code>会在<code>sys.argv</code>中自动解析相应的参数。</em></p><h2 id="ArgumentParser对象"><a href="#ArgumentParser对象" class="headerlink" title="ArgumentParser对象"></a>ArgumentParser对象</h2><p><code>ArgumentParser</code>对象定义如下：</p><pre><code>class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars=&apos;-&apos;, fromfile_prefix_chars=None, argument_default=None, conflict_handler=&apos;error&apos;, add_help=True)</code></pre><p>其每一个参数的定义如下：</p><ul><li><p>prog - The name of the program (default: sys.argv[0])<br>  默认情况下, ArgumentParser对象根据sys.argv[0]的值(不包括路径名)生成帮助信息中的程序名。</p></li><li><p>usage - The string describing the program usage (default: generated from arguments added to parser)<br>  默认情况下，ArgumentParser对象可以根据参数自动生成用法信息</p></li><li><p><strong>description - Text to display before the argument help (default: none)</strong><br>  description 用于展示程序的简要介绍信息，通常包括:这个程序可以做什么、怎么做。在帮助信息中 description位于用法信息与参数说明之间</p></li><li><p>epilog - Text to display after the argument help (default: none)<br>  与description类似，程序的额外描述信息，位于参数说明之后</p></li><li><p>parents - A list of ArgumentParser objects whose arguments should also be included<br>  有时多个解析器可能有相同的参数集，为了实现代码复用，我们可以将这些相同的参数集提取到一个单独的解析器中，在创建其它解析器时通过parents指定父解析器，这样新创建的解析器中就包含了相同的参数集。</p></li><li><p>formatter_class - A class for customizing the help output<br>  通过 formatter_class 可以定制帮助信息</p></li><li><p>prefix_chars - The set of characters that prefix optional arguments (default: ‘-‘)<br>  一般情况下，我们使用’-‘作为选项前缀,ArgumentParser也支持自定义选项前缀,通过prefix_chars</p></li><li><p>fromfile_prefix_chars - The set of characters that prefix files from which additional arguments should be read (default: None)</p></li></ul><ul><li>argument_default - The global default value for arguments (default: None)</li></ul><ul><li>conflict_handler - The strategy for resolving conflicting optionals (usually unnecessary)</li></ul><ul><li>add_help - Add a -h/–help option to the parser (default: True)<br>  是否禁用-h –help选项</li></ul><p><em>个人认为常用的参数使用黑体标出，基本上如果没有特别需求就指定一下description就可以了。<br>官网和一些参考文献中都给出了每个参数的详细定义和具体使用方法，这里不在赘述。</em></p><h3 id="add-argument-方法"><a href="#add-argument-方法" class="headerlink" title="add_argument()方法"></a>add_argument()方法</h3><p>ArgumentParser.add_argument(name or flags…[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</p><p>各个参数含义如下：</p><ul><li><p><strong>name or flags - Either a name or a list of option strings, e.g. foo or -f, –foo.</strong><br>  指定一个可选参数或者位置参数。<em>其中可选参数以-开头，剩下的是位置参数</em></p></li><li><p><strong>action - The basic type of action to be taken when this argument is encountered at the command line.</strong><br>  指定如何处理命令行参数</p></li><li><p><strong>nargs - The number of command-line arguments that should be consumed.</strong><br>  指定多个命令行参数和一个arcion相关联，具体见<a href="https://docs.python.org/3.4/library/argparse.html#the-add-argument-method" target="_blank" rel="noopener">官方文档</a></p></li><li><p><strong>const - A constant value required by some action and nargs selections.</strong><br>  constant value，不是从命令行中读取，在某些特定action中需要指定。</p></li><li><p><strong>default - The value produced if the argument is absent from the command line.</strong><br>  如果参数可以缺省，default指定命令行参数不存在时的参数值。</p></li><li><p><strong>type - The type to which the command-line argument should be converted.</strong><br>  默认情况下，ArgumentParser对象将命令行参数保存为字符串。但通常命令行参数应该被解释为另一种类型，如 float或int。通过指定type,可以对命令行参数执行类型检查和类型转换</p></li><li><p><strong>choices - A container of the allowable values for the argument.</strong><br>  将命令行参数的值限定在一个范围内，超出范围则报错 </p></li><li><p>required - Whether or not the command-line option may be omitted (optionals only).<br>  指定命令行参数是否必需，默认通过-f –foo指定的参数为可选参数。    </p></li><li><p><strong>help - A brief description of what the argument does.</strong><br>  帮助文档</p></li><li><p>metavar - A name for the argument in usage messages.<br>  写帮助文档时可选的参数</p></li><li><p>dest - The name of the attribute to be added to the object returned by parse_args().<br>  dest 允许自定义ArgumentParser的参数属性名称 </p></li></ul><h2 id="最后来个示范"><a href="#最后来个示范" class="headerlink" title="最后来个示范"></a>最后来个示范</h2><p>常用的参数基本都列出来了，接下来用<a href="http://pytorch.org/" target="_blank" rel="noopener">Pytorch</a>源码中的一个小例子演示用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'PyTorch MNIST Example'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--batch-size'</span>, type=int, default=<span class="number">64</span>, metavar=<span class="string">'N'</span>,</span><br><span class="line">                    help=<span class="string">'input batch size for training (default: 64)'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--test-batch-size'</span>, type=int, default=<span class="number">1000</span>, metavar=<span class="string">'N'</span>,</span><br><span class="line">                    help=<span class="string">'input batch size for testing (default: 1000)'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--epochs'</span>, type=int, default=<span class="number">10</span>, metavar=<span class="string">'N'</span>,</span><br><span class="line">                    help=<span class="string">'number of epochs to train (default: 10)'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--lr'</span>, type=float, default=<span class="number">0.01</span>, metavar=<span class="string">'LR'</span>,</span><br><span class="line">                    help=<span class="string">'learning rate (default: 0.01)'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--momentum'</span>, type=float, default=<span class="number">0.5</span>, metavar=<span class="string">'M'</span>,</span><br><span class="line">                    help=<span class="string">'SGD momentum (default: 0.5)'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--no-cuda'</span>, action=<span class="string">'store_true'</span>, default=<span class="literal">False</span>,</span><br><span class="line">                    help=<span class="string">'disables CUDA training'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--seed'</span>, type=int, default=<span class="number">1</span>, metavar=<span class="string">'S'</span>,</span><br><span class="line">                    help=<span class="string">'random seed (default: 1)'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--log-interval'</span>, type=int, default=<span class="number">10</span>, metavar=<span class="string">'N'</span>,</span><br><span class="line">                    help=<span class="string">'how many batches to wait before logging training status'</span>)</span><br><span class="line">args = parser.parse_args()</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol><li><a href="http://blog.csdn.net/ali197294332/article/details/51180628" target="_blank" rel="noopener">python 中的argparse</a></li><li><a href="http://blog.csdn.net/guoyajie1990/article/details/76739977" target="_blank" rel="noopener">python命令行解析模块argparse</a></li><li><a href="https://docs.python.org/3.4/library/argparse.html#module-argparse" target="_blank" rel="noopener">官方文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deep learning: Ubuntu16.04 安装caffe python版 无GPU</title>
      <link href="/2018/02/18/ubuntu-install-caffe-without-gpu/"/>
      <url>/2018/02/18/ubuntu-install-caffe-without-gpu/</url>
      
        <content type="html"><![CDATA[<p>其实发现直接按照官网上的配置步骤一点一点走完完全就可以搭建出来。<br>中间会出现两个小插曲，一个是ubuntu16.04系统的一些变动导致；另一个是使用了anaconda的原因，在网上找了一些资料，发现很多人最终选择不使用anaconda，选择直接使用系统自带的python，我也图省事儿选择了系统自带的Python。</p><p>这里我主要按照官网的安装指南进行说明，中途列出我遇到的一些情况。</p><a id="more"></a><h3 id="安装支持包"><a href="#安装支持包" class="headerlink" title="安装支持包"></a>安装支持包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler</span><br><span class="line">sudo apt-get install --no-install-recommends libboost-all-dev</span><br><span class="line">sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev</span><br></pre></td></tr></table></figure><p><strong>BLAS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libatlas-base-dev</span><br></pre></td></tr></table></figure><p><strong>python包</strong></p><p><em>（这一步需要先git clone之后cd python 再运行，为了给make过程提供支持）</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> req <span class="keyword">in</span> $(cat requirements.txt); <span class="keyword">do</span> pip install <span class="variable">$req</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><hr><h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/bvlc/caffe.git </span><br><span class="line"><span class="built_in">cd</span> caffe/</span><br><span class="line">mv Makefile.fonfig.example Makefile.cofig</span><br><span class="line">vim Makefile.config</span><br></pre></td></tr></table></figure><ul><li>首先去掉取消CPU_ONLY的注释， 因为没安装GPU：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CPU-only switch (uncomment to build without GPU support).</span></span><br><span class="line">CPU_ONLY := 1</span><br></pre></td></tr></table></figure><ul><li>Python库路径由于使用的是系统自带Python所以不需要修改，需要在LIBRARY_DIRS一行后面加一个库路径，另外，由于在ubuntu16.04中hdf5头文件和库文件默认路径发生了变化，因此需要在INCLUDE_DIRS下增加hdf5的路径如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/<span class="built_in">local</span>/include /usr/include/hdf5/serial/</span><br><span class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/<span class="built_in">local</span>/lib /usr/lib /usr/lib/x86_64-linux-gnu</span><br></pre></td></tr></table></figure><ul><li>修改Makefile。退出Makefile.config，同样在Makefile中修改fdf5的相关信息，将LIBRARIES中的hdf5_h1和hdf5修改成hdf5_serial_h1和hdf5_serial，修改之后的信息如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIBRARIES += glog gflags protobuf boost_system boost_filesystem m hdf5_serial_hl hdf5_serial</span><br></pre></td></tr></table></figure><ul><li><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line">make runtest</span><br><span class="line">make pycaffe</span><br></pre></td></tr></table></figure></li><li><p>注意，在make pycaffe之前一定要保证安装了步骤1中的python支持包。*</p></li><li><p>设置PYTHONPATH<br>官网建议设置pythonpath，操作如下，在~/home路径下修改.bashrc文件，最后一行加上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PYTHONPATH=/home/xxx/caffe/python:<span class="variable">$PYTHONPATH</span></span><br></pre></td></tr></table></figure><p>中间xx改成对应路径即可。<br>退出后source .bashrc使生效</p></li></ul><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> caffe</span><br></pre></td></tr></table></figure><hr><p><strong>下面列出使用anaconda中遇到的一些情况，对已经安装成功的人来说可以选择不看。</strong><br>安装过程中和<a href="http://www.voidcn.com/blog/u010734277/article/p-6560868.html在处理anaconda的问题上基本相同。" target="_blank" rel="noopener">http://www.voidcn.com/blog/u010734277/article/p-6560868.html在处理anaconda的问题上基本相同。</a><br>       在使用anaconda安装时，基本步骤和我上面的安装步骤相同，只是在编辑Makefile.config文件时把对应anaconda的包含目录和库目录取消注释，并注释掉系统自带的python包含目录和库目录。<br>       Make all时就出错了，这里直接把别人的错误信息粘过来：<br>collect2: error: ld returned 1 exit status<br>Makefile:627: recipe for target’.build_release/tools/extract_features.bin ‘failed<br>make: *** [.build_release/tools/extract_features.bin] Error 1<br>但是把anaconda的路径写错就可以编译过去make all， make test和make runtest。于是选择在make前三个时候将Makefile.config中的anaconda路径写错，make pycaff时候在写对(因为上面那个人说前三个编译时候不需要anaconda中的包含文件和库文件，所以可以这么做)，于是就完全编译通过了。<br>最终在使用的时候又出现了新的错误，好像是和opencv有关的错误，我使用conda安装过一个opencv，使用apt-get安装过一个，不知道会不会有关系，以后有机会可以继续解决一下。</p>]]></content>
      
      
      <categories>
          
          <category> deep learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> deep learning </tag>
            
            <tag> ubuntu </tag>
            
            <tag> caffe </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
